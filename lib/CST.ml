(* Generated by ocaml-tree-sitter. *)
(*
   sqlite grammar

   entrypoint: sql_stmt_list
*)

open! Sexplib.Conv
open Tree_sitter_run

type rowid = Token.t (* pattern [rR][oO][wW][iI][dD] *)

type escape = Token.t (* pattern [eE][sS][cC][aA][pP][eE] *)

type range = Token.t (* pattern [rR][aA][nN][gG][eE] *)

type immediate = Token.t (* pattern [iI][mM][mM][eE][dD][iI][aA][tT][eE] *)

type natural = Token.t (* pattern [nN][aA][tT][uU][rR][aA][lL] *)

type before = Token.t (* pattern [bB][eE][fF][oO][rR][eE] *)

type create = Token.t (* pattern [cC][rR][eE][aA][tT][eE] *)

type all = Token.t (* pattern [aA][lL][lL] *)

type to_ = Token.t (* pattern [tT][oO] *)

type deferrable =
  Token.t (* pattern [dD][eE][fF][eE][rR][rR][aA][bB][lL][eE] *)

type ignore = Token.t (* pattern [iI][gG][nN][oO][rR][eE] *)

type if_ = Token.t (* pattern [iI][fF] *)

type index = Token.t (* pattern [iI][nN][dD][eE][xX] *)

type union = Token.t (* pattern [uU][nN][iI][oO][nN] *)

type insert = Token.t (* pattern [iI][nN][sS][eE][rR][tT] *)

type over = Token.t (* pattern [oO][vV][eE][rR] *)

type exclude = Token.t (* pattern [eE][xX][cC][lL][uU][dD][eE] *)

type nothing = Token.t (* pattern [nN][oO][tT][hH][iI][nN][gG] *)

type first = Token.t (* pattern [fF][iI][rR][sS][tT] *)

type with_ = Token.t (* pattern [wW][iI][tT][hH] *)

type current = Token.t (* pattern [cC][uU][rR][rR][eE][nN][tT] *)

type when_ = Token.t (* pattern [wW][hH][eE][nN] *)

type raise = Token.t (* pattern [rR][aA][iI][sS][eE] *)

type by = Token.t (* pattern [bB][yY] *)

type last = Token.t (* pattern [lL][aA][sS][tT] *)

type anon_choice_PLUS_da42005 = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
]

type or_ = Token.t (* pattern [oO][rR] *)

type virtual_ = Token.t (* pattern [vV][iI][rR][tT][uU][aA][lL] *)

type references =
  Token.t (* pattern [rR][eE][fF][eE][rR][eE][nN][cC][eE][sS] *)

type distinct = Token.t (* pattern [dD][iI][sS][tT][iI][nN][cC][tT] *)

type pat_93c883a = Token.t (* pattern [$_0-9a-zA-Z\x80-\xFF]+ *)

type unbounded = Token.t (* pattern [uU][nN][bB][oO][uU][nN][dD][eE][dD] *)

type analyze = Token.t (* pattern [aA][nN][aA][lL][yY][zZ][eE] *)

type preceding = Token.t (* pattern [pP][rR][eE][cC][eE][dD][iI][nN][gG] *)

type transaction =
  Token.t (* pattern [tT][rR][aA][nN][sS][aA][cC][tT][iI][oO][nN] *)

type true_ = Token.t (* pattern [tT][rR][uU][eE] *)

type generated = Token.t (* pattern [gG][eE][nN][eE][rR][aA][tT][eE][dD] *)

type end_ = Token.t (* pattern [eE][nN][dD] *)

type limit = Token.t (* pattern [lL][iI][mM][iI][tT] *)

type join = Token.t (* pattern [jJ][oO][iI][nN] *)

type on = Token.t (* pattern [oO][nN] *)

type action = Token.t (* pattern [aA][cC][tT][iI][oO][nN] *)

type except = Token.t (* pattern [eE][xX][cC][eE][pP][tT] *)

type else_ = Token.t (* pattern [eE][lL][sS][eE] *)

type do_ = Token.t (* pattern [dD][oO] *)

type after = Token.t (* pattern [aA][fF][tT][eE][rR] *)

type notnull = Token.t (* pattern [nN][oO][tT][nN][uU][lL][lL] *)

type autoincrement =
  Token.t (* pattern [aA][uU][tT][oO][iI][nN][cC][rR][eE][mM][eE][nN][tT] *)

type asc = Token.t (* pattern [aA][sS][cC] *)

type from = Token.t (* pattern [fF][rR][oO][mM] *)

type initially = Token.t (* pattern [iI][nN][iI][tT][iI][aA][lL][lL][yY] *)

type recursive = Token.t (* pattern [rR][eE][cC][uU][rR][sS][iI][vV][eE] *)

type collate = Token.t (* pattern [cC][oO][lL][lL][aA][tT][eE] *)

type each = Token.t (* pattern [eE][aA][cC][hH] *)

type no = Token.t (* pattern [nN][oO] *)

type temporary = Token.t (* pattern [tT][eE][mM][pP][oO][rR][aA][rR][yY] *)

type current_date =
  Token.t (* pattern [cC][uU][rR][rR][eE][nN][tT][__][dD][aA][tT][eE] *)

type plan = Token.t (* pattern [pP][lL][aA][nN] *)

type left = Token.t (* pattern [lL][eE][fF][tT] *)

type row = Token.t (* pattern [rR][oO][wW] *)

type explain = Token.t (* pattern [eE][xX][pP][lL][aA][iI][nN] *)

type having = Token.t (* pattern [hH][aA][vV][iI][nN][gG] *)

type begin_ = Token.t (* pattern [bB][eE][gG][iI][nN] *)

type group = Token.t (* pattern [gG][rR][oO][uU][pP] *)

type in_ = Token.t (* pattern [iI][nN] *)

type values = Token.t (* pattern [vV][aA][lL][uU][eE][sS] *)

type trigger = Token.t (* pattern [tT][rR][iI][gG][gG][eE][rR] *)

type null = Token.t (* pattern [nN][uU][lL][lL] *)

type deferred = Token.t (* pattern [dD][eE][fF][eE][rR][rR][eE][dD] *)

type window = Token.t (* pattern [wW][iI][nN][dD][oO][wW] *)

type restrict = Token.t (* pattern [rR][eE][sS][tT][rR][iI][cC][tT] *)

type select = Token.t (* pattern [sS][eE][lL][eE][cC][tT] *)

type indexed = Token.t (* pattern [iI][nN][dD][eE][xX][eE][dD] *)

type partition = Token.t (* pattern [pP][aA][rR][tT][iI][tT][iI][oO][nN] *)

type using = Token.t (* pattern [uU][sS][iI][nN][gG] *)

type others = Token.t (* pattern [oO][tT][hH][eE][rR][sS] *)

type cascade = Token.t (* pattern [cC][aA][sS][cC][aA][dD][eE] *)

type following = Token.t (* pattern [fF][oO][lL][lL][oO][wW][iI][nN][gG] *)

type release = Token.t (* pattern [rR][eE][lL][eE][aA][sS][eE] *)

type ties = Token.t (* pattern [tT][iI][eE][sS] *)

type detach = Token.t (* pattern [dD][eE][tT][aA][cC][hH] *)

type cross = Token.t (* pattern [cC][rR][oO][sS][sS] *)

type isnull = Token.t (* pattern [iI][sS][nN][uU][lL][lL] *)

type not = Token.t (* pattern [nN][oO][tT] *)

type inner = Token.t (* pattern [iI][nN][nN][eE][rR] *)

type update = Token.t (* pattern [uU][pP][dD][aA][tT][eE] *)

type database = Token.t (* pattern [dD][aA][tT][aA][bB][aA][sS][eE] *)

type pat_4fd4a56 = Token.t (* pattern .* *)

type current_timestamp =
  Token.t (* pattern [cC][uU][rR][rR][eE][nN][tT][__][tT][iI][mM][eE][sS][tT][aA][mM][pP] *)

type set = Token.t (* pattern [sS][eE][tT] *)

type primary = Token.t (* pattern [pP][rR][iI][mM][aA][rR][yY] *)

type temp = Token.t (* pattern [tT][eE][mM][pP] *)

type pat_f79575e = Token.t (* pattern "(''|[^'])*" *)

type order = Token.t (* pattern [oO][rR][dD][eE][rR] *)

type outer = Token.t (* pattern [oO][uU][tT][eE][rR] *)

type is = Token.t (* pattern [iI][sS] *)

type numeric_literal = Token.t

type pat_f154b4a = Token.t (* pattern [^\]]* *)

type pat_73398bc = Token.t (* pattern "(\"\"|[^\"])*" *)

type pragma = Token.t (* pattern [pP][rR][aA][gG][mM][aA] *)

type table = Token.t (* pattern [tT][aA][bB][lL][eE] *)

type column = Token.t (* pattern [cC][oO][lL][uU][mM][nN] *)

type default = Token.t (* pattern [dD][eE][fF][aA][uU][lL][tT] *)

type vacuum = Token.t (* pattern [vV][aA][cC][uU][uU][mM] *)

type false_ = Token.t (* pattern [fF][aA][lL][sS][eE] *)

type instead = Token.t (* pattern [iI][nN][sS][tT][eE][aA][dD] *)

type of_ = Token.t (* pattern [oO][fF] *)

type current_time =
  Token.t (* pattern [cC][uU][rR][rR][eE][nN][tT][__][tT][iI][mM][eE] *)

type exists = Token.t (* pattern [eE][xX][iI][sS][tT][sS] *)

type reindex = Token.t (* pattern [rR][eE][iI][nN][dD][eE][xX] *)

type rows = Token.t (* pattern [rR][oO][wW][sS] *)

type cast = Token.t (* pattern [cC][aA][sS][tT] *)

type like = Token.t (* pattern [lL][iI][kK][eE] *)

type constraint_ =
  Token.t (* pattern [cC][oO][nN][sS][tT][rR][aA][iI][nN][tT] *)

type regexp = Token.t (* pattern [rR][eE][gG][eE][xX][pP] *)

type materialized =
  Token.t (* pattern [mM][aA][tT][eE][rR][iI][aA][lL][iI][zZ][eE][dD] *)

type offset = Token.t (* pattern [oO][fF][fF][sS][eE][tT] *)

type pat_05bf793 = Token.t (* pattern [^*]*\*+([^/*][^*]*\*+)* *)

type drop = Token.t (* pattern [dD][rR][oO][pP] *)

type attach = Token.t (* pattern [aA][tT][tT][aA][cC][hH] *)

type view = Token.t (* pattern [vV][iI][eE][wW] *)

type without = Token.t (* pattern [wW][iI][tT][hH][oO][uU][tT] *)

type between = Token.t (* pattern [bB][eE][tT][wW][eE][eE][nN] *)

type pat_213dc3e = Token.t (* pattern [0-9] *)

type stored = Token.t (* pattern [sS][tT][oO][rR][eE][dD] *)

type where = Token.t (* pattern [wW][hH][eE][rR][eE] *)

type alter = Token.t (* pattern [aA][lL][tT][eE][rR] *)

type for_ = Token.t (* pattern [fF][oO][rR] *)

type key = Token.t (* pattern [kK][eE][yY] *)

type savepoint = Token.t (* pattern [sS][aA][vV][eE][pP][oO][iI][nN][tT] *)

type glob = Token.t (* pattern [gG][lL][oO][bB] *)

type query = Token.t (* pattern [qQ][uU][eE][rR][yY] *)

type groups = Token.t (* pattern [gG][rR][oO][uU][pP][sS] *)

type intersect = Token.t (* pattern [iI][nN][tT][eE][rR][sS][eE][cC][tT] *)

type case = Token.t (* pattern [cC][aA][sS][eE] *)

type delete = Token.t (* pattern [dD][eE][lL][eE][tT][eE] *)

type replace = Token.t (* pattern [rR][eE][pP][lL][aA][cC][eE] *)

type pat_29ffae5 =
  Token.t (* pattern [_a-zA-Z\x80-\xFF][$_0-9a-zA-Z\x80-\xFF]* *)

type then_ = Token.t (* pattern [tT][hH][eE][nN] *)

type foreign = Token.t (* pattern [fF][oO][rR][eE][iI][gG][nN] *)

type into = Token.t (* pattern [iI][nN][tT][oO] *)

type and_ = Token.t (* pattern [aA][nN][dD] *)

type abort = Token.t (* pattern [aA][bB][oO][rR][tT] *)

type nulls = Token.t (* pattern [nN][uU][lL][lL][sS] *)

type conflict = Token.t (* pattern [cC][oO][nN][fF][lL][iI][cC][tT] *)

type pat_bb5937d = Token.t (* pattern (``|[^`])* *)

type returning = Token.t (* pattern [rR][eE][tT][uU][rR][nN][iI][nN][gG] *)

type desc = Token.t (* pattern [dD][eE][sS][cC] *)

type exclusive = Token.t (* pattern [eE][xX][cC][lL][uU][sS][iI][vV][eE] *)

type unique = Token.t (* pattern [uU][nN][iI][qQ][uU][eE] *)

type always = Token.t (* pattern [aA][lL][wW][aA][yY][sS] *)

type filter = Token.t (* pattern [fF][iI][lL][tT][eE][rR] *)

type check = Token.t (* pattern [cC][hH][eE][cC][kK] *)

type rename = Token.t (* pattern [rR][eE][nN][aA][mM][eE] *)

type match_ = Token.t (* pattern [mM][aA][tT][cC][hH] *)

type rollback = Token.t (* pattern [rR][oO][lL][lL][bB][aA][cC][kK] *)

type commit = Token.t (* pattern [cC][oO][mM][mM][iI][tT] *)

type fail = Token.t (* pattern [fF][aA][iI][lL] *)

type add = Token.t (* pattern [aA][dD][dD] *)

type as_ = Token.t (* pattern [aA][sS] *)

type anon_choice_temp_716f4ac = [
    `Temp_3d801aa of temp (*tok*)
  | `Temp_d5197d9 of temporary (*tok*)
]

type string_ = (Token.t (* "'" *) * pat_f79575e * Token.t (* "'" *))

type join_operator = [
    `COMMA of Token.t (* "," *)
  | `Opt_natu_opt_choice_left_opt_outer_join of (
        natural (*tok*) option
      * [
            `Left_opt_outer of (left (*tok*) * outer (*tok*) option)
          | `Inner of inner (*tok*)
          | `Cross of cross (*tok*)
        ]
          option
      * join (*tok*)
    )
]

type signed_number = (
    anon_choice_PLUS_da42005 option
  * numeric_literal (*tok*)
)

type bind_parameter = [
    `QMARK_rep_pat_213dc3e of (
        Token.t (* "?" *)
      * pat_213dc3e list (* zero or more *)
    )
  | `Choice_AT_pat_93c883a of (
        [
            `AT of Token.t (* "@" *)
          | `DOLLAR of Token.t (* "$" *)
          | `COLON of Token.t (* ":" *)
          | `HASH of Token.t (* "#" *)
        ]
      * pat_93c883a
    )
]

type compound_operator = [
    `Union of union (*tok*)
  | `Union_all of (union (*tok*) * all (*tok*))
  | `Inte of intersect (*tok*)
  | `Except of except (*tok*)
]

type identifier = [
    `Pat_29ffae5 of pat_29ffae5
  | `DQUOT_pat_73398bc_DQUOT of (
        Token.t (* "\"" *) * pat_73398bc * Token.t (* "\"" *)
    )
  | `BQUOT_pat_bb5937d_BQUOT of (
        Token.t (* "`" *) * pat_bb5937d * Token.t (* "`" *)
    )
  | `LBRACK_pat_f154b4a_RBRACK of (
        Token.t (* "[" *) * pat_f154b4a * Token.t (* "]" *)
    )
]

type anon_choice_asc_fa4fd8b = [
    `Asc of asc (*tok*)
  | `Desc of desc (*tok*)
]

type anon_choice_abort_500a898 = [
    `Abort of abort (*tok*)
  | `Fail of fail (*tok*)
  | `Ignore of ignore (*tok*)
  | `Repl of replace (*tok*)
  | `Roll of rollback (*tok*)
]

type conflict_clause = (
    on (*tok*)
  * conflict (*tok*)
  * [
        `Roll of rollback (*tok*)
      | `Abort of abort (*tok*)
      | `Fail of fail (*tok*)
      | `Ignore of ignore (*tok*)
      | `Repl of replace (*tok*)
    ]
)

type string_literal = string_

type function_name = identifier

type name = [ `Str_lit of string_literal | `Id of function_name ]

type collation_name = [ `Str_lit of string_literal | `Id of function_name ]

type literal_value = [
    `Nume_lit of numeric_literal (*tok*)
  | `Str_lit of string_literal
  | `Blob_lit of (
        [ `X_9dd4e46 of Token.t (* "x" *) | `X_02129bb of Token.t (* "X" *) ]
      * string_literal
    )
  | `Null of null (*tok*)
  | `True of true_ (*tok*)
  | `False of false_ (*tok*)
  | `Curr_time_95f1cf7 of current_time (*tok*)
  | `Curr_date of current_date (*tok*)
  | `Curr_time_72fc600 of current_timestamp (*tok*)
]

type error_message = name

type anon_opt_opt_as_error_mess_6e99511 =
  (as_ (*tok*) option * error_message) option

type name2 = ((error_message * Token.t (* "." *)) option * error_message)

type savepoint_stmt = (savepoint (*tok*) * error_message)

type type_name = (
    error_message list (* one or more *)
  * [
        `LPAR_signed_num_RPAR of (
            Token.t (* "(" *) * signed_number * Token.t (* ")" *)
        )
      | `LPAR_signed_num_COMMA_signed_num_RPAR of (
            Token.t (* "(" *) * signed_number * Token.t (* "," *)
          * signed_number * Token.t (* ")" *)
        )
    ]
      option
)

type pragma_value = [ `Signed_num of signed_number | `Name of error_message ]

type anon_choice_inde_by_error_mess_0500888 = [
    `Inde_by_name of (indexed (*tok*) * by (*tok*) * error_message)
  | `Not_inde of (not (*tok*) * indexed (*tok*))
]

type detach_stmt = (detach (*tok*) * database (*tok*) option * error_message)

type anon_opt_tran_opt_error_mess_65fc71e =
  (transaction (*tok*) * error_message option) option

type release_stmt = (
    release (*tok*)
  * savepoint (*tok*) option
  * error_message
)

type column_name_list = (
    Token.t (* "(" *)
  * error_message
  * (Token.t (* "," *) * error_message) list (* zero or more *)
  * Token.t (* ")" *)
)

type analyze_stmt = (analyze (*tok*) * name2 option)

type reindex_stmt = (reindex (*tok*) * name2 option)

type drop_trigger_stmt = (
    drop (*tok*)
  * trigger (*tok*)
  * (if_ (*tok*) * exists (*tok*)) option
  * name2
)

type drop_view_stmt = (
    drop (*tok*)
  * view (*tok*)
  * (if_ (*tok*) * exists (*tok*)) option
  * name2
)

type drop_table_stmt = (
    drop (*tok*)
  * table (*tok*)
  * (if_ (*tok*) * exists (*tok*)) option
  * name2
)

type drop_index_stmt = (
    drop (*tok*)
  * index (*tok*)
  * (if_ (*tok*) * exists (*tok*)) option
  * name2
)

type pragma_stmt = (
    pragma (*tok*)
  * name2
  * [
        `EQ_pragma_value of (Token.t (* "=" *) * pragma_value)
      | `LPAR_pragma_value_RPAR of (
            Token.t (* "(" *) * pragma_value * Token.t (* ")" *)
        )
    ]
      option
)

type qualified_table_name = (
    name2
  * (as_ (*tok*) * error_message) option
  * anon_choice_inde_by_error_mess_0500888 option
)

type rollback_stmt = (
    rollback (*tok*)
  * anon_opt_tran_opt_error_mess_65fc71e
  * (to_ (*tok*) * savepoint (*tok*) option * error_message) option
)

type begin_stmt = (
    begin_ (*tok*)
  * [
        `Defe of deferred (*tok*)
      | `Imme of immediate (*tok*)
      | `Excl of exclusive (*tok*)
    ]
      option
  * anon_opt_tran_opt_error_mess_65fc71e
)

type commit_stmt = (
    [ `Commit of commit (*tok*) | `End of end_ (*tok*) ]
  * anon_opt_tran_opt_error_mess_65fc71e
)

type anon_choice_error_mess_facbc16 = [
    `Name of error_message
  | `Column_name_list of column_name_list
]

type anon_COMMA_LPAR_file_rep_COMMA_file_RPAR_a378f47 = (
    Token.t (* "," *)
  * Token.t (* "(" *)
  * filename
  * (Token.t (* "," *) * filename) list (* zero or more *)
  * Token.t (* ")" *)
)

and anon_file_rep_COMMA_file_3ba9398 = (
    filename
  * (Token.t (* "," *) * filename) list (* zero or more *)
)

and common_table_expression = [
  `Rectype of (
      error_message
    * column_name_list option
    * as_ (*tok*)
    * (not (*tok*) option * materialized (*tok*)) option
    * Token.t (* "(" *)
    * select_stmt
    * Token.t (* ")" *)
  )
]

and expr = [
    `Lit_value of literal_value
  | `Bind_param of bind_parameter
  | `Name of error_message
  | `Name_DOT_name of (error_message * Token.t (* "." *) * error_message)
  | `Name_DOT_name_DOT_name of (
        error_message * Token.t (* "." *) * error_message * Token.t (* "." *)
      * error_message
    )
  | `TILDE_expr of (Token.t (* "~" *) * filename)
  | `Choice_DASH_expr of (
        [ `DASH of Token.t (* "-" *) | `PLUS of Token.t (* "+" *) ]
      * filename
    )
  | `Not_expr of (not (*tok*) * filename)
  | `Expr_BARBAR_expr of (filename * Token.t (* "||" *) * filename)
  | `Expr_choice_STAR_expr of (
        filename
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
        ]
      * filename
    )
  | `Expr_choice_PLUS_expr of (
        filename * anon_choice_PLUS_da42005 * filename
    )
  | `Expr_choice_LTLT_expr of (
        filename
      * [
            `LTLT of Token.t (* "<<" *)
          | `GTGT of Token.t (* ">>" *)
          | `AMP of Token.t (* "&" *)
          | `BAR of Token.t (* "|" *)
        ]
      * filename
    )
  | `Expr_choice_LT_expr of (
        filename
      * [
            `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
        ]
      * filename
    )
  | `Expr_choice_EQ_expr of (
        filename
      * [
            `EQ of Token.t (* "=" *)
          | `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `LTGT of Token.t (* "<>" *)
        ]
      * filename
    )
  | `Expr_opt_not_in_choice_LPAR_opt_choice_select_stmt_RPAR of (
        filename
      * not (*tok*) option
      * in_ (*tok*)
      * [
            `LPAR_opt_choice_select_stmt_RPAR of (
                Token.t (* "(" *)
              * [
                    `Select_stmt of select_stmt
                  | `Expr_rep_COMMA_expr of anon_file_rep_COMMA_file_3ba9398
                ]
                  option
              * Token.t (* ")" *)
            )
          | `Name2_opt_LPAR_opt_expr_rep_COMMA_expr_RPAR of (
                name2
              * (
                    Token.t (* "(" *)
                  * anon_file_rep_COMMA_file_3ba9398 option
                  * Token.t (* ")" *)
                )
                  option
            )
        ]
    )
  | `Expr_and_expr of (filename * and_ (*tok*) * filename)
  | `Expr_or_expr of (filename * or_ (*tok*) * filename)
  | `Func_name_LPAR_opt_choice_opt_dist_expr_rep_COMMA_expr_RPAR_opt_filter_clause_opt_over_clause of (
        function_name
      * Token.t (* "(" *)
      * [
            `Opt_dist_expr_rep_COMMA_expr of (
                distinct (*tok*) option
              * filename
              * (Token.t (* "," *) * filename) list (* zero or more *)
            )
          | `STAR of Token.t (* "*" *)
        ]
          option
      * Token.t (* ")" *)
      * filter_clause option
      * over_clause option
    )
  | `LPAR_expr_rep_COMMA_expr_RPAR of (
        Token.t (* "(" *)
      * filename
      * (Token.t (* "," *) * filename) list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `Cast_LPAR_expr_as_type_name_RPAR of (
        cast (*tok*) * Token.t (* "(" *) * filename * as_ (*tok*) * type_name
      * Token.t (* ")" *)
    )
  | `Expr_coll_coll_name of (filename * collate (*tok*) * collation_name)
  | `Expr_opt_not_choice_like_expr_opt_esc_expr of (
        filename
      * not (*tok*) option
      * [
            `Like of like (*tok*)
          | `Glob of glob (*tok*)
          | `Regex of regexp (*tok*)
          | `Match of match_ (*tok*)
        ]
      * filename
      * (escape (*tok*) * filename) option
    )
  | `Expr_choice_isnull of (
        filename
      * [
            `Isnull of isnull (*tok*)
          | `Notn of notnull (*tok*)
          | `Not_null of (not (*tok*) * null (*tok*))
        ]
    )
  | `Expr_is_opt_not_expr of (
        filename
      * is (*tok*)
      * not (*tok*) option
      * filename
    )
  | `Expr_opt_not_betw_expr_and_expr of (
        filename
      * not (*tok*) option
      * between (*tok*)
      * filename
      * and_ (*tok*)
      * filename
    )
  | `LPAR_select_stmt_RPAR of (
        Token.t (* "(" *) * select_stmt * Token.t (* ")" *)
    )
  | `Exists_LPAR_select_stmt_RPAR of (
        exists (*tok*) * Token.t (* "(" *) * select_stmt * Token.t (* ")" *)
    )
  | `Not_exists_LPAR_select_stmt_RPAR of (
        not (*tok*) * exists (*tok*) * Token.t (* "(" *) * select_stmt
      * Token.t (* ")" *)
    )
  | `Case_opt_expr_rep1_when_expr_then_expr_opt_else_expr_end of (
        case (*tok*)
      * filename option
      * (when_ (*tok*) * filename * then_ (*tok*) * filename)
          list (* one or more *)
      * (else_ (*tok*) * filename) option
      * end_ (*tok*)
    )
  | `Raise_func of (
        raise (*tok*)
      * Token.t (* "(" *)
      * [
            `Ignore of ignore (*tok*)
          | `Choice_roll_COMMA_error_mess of (
                [
                    `Roll of rollback (*tok*)
                  | `Abort of abort (*tok*)
                  | `Fail of fail (*tok*)
                ]
              * Token.t (* "," *)
              * error_message
            )
        ]
      * Token.t (* ")" *)
    )
]

and filename = expr

and filter_clause = (
    filter (*tok*) * Token.t (* "(" *) * where (*tok*) * filename
  * Token.t (* ")" *)
)

and frame_spec = (
    [
        `Range of range (*tok*)
      | `Rows of rows (*tok*)
      | `Groups of groups (*tok*)
    ]
  * [
        `Betw_choice_unbo_prec_and_choice_expr_prec of (
            between (*tok*)
          * [
                `Unbo_prec of (unbounded (*tok*) * preceding (*tok*))
              | `Expr_prec of (filename * preceding (*tok*))
              | `Curr_row of (current (*tok*) * row (*tok*))
              | `Expr_foll of (filename * following (*tok*))
            ]
          * and_ (*tok*)
          * [
                `Expr_prec of (filename * preceding (*tok*))
              | `Curr_row of (current (*tok*) * row (*tok*))
              | `Expr_foll of (filename * following (*tok*))
              | `Unbo_foll of (unbounded (*tok*) * following (*tok*))
            ]
        )
      | `Unbo_prec of (unbounded (*tok*) * preceding (*tok*))
      | `Expr_prec of (filename * preceding (*tok*))
      | `Curr_row of (current (*tok*) * row (*tok*))
    ]
  * (
        exclude (*tok*)
      * [
            `Not_others of (not (*tok*) * others (*tok*))
          | `Curr_row of (current (*tok*) * row (*tok*))
          | `Group of group (*tok*)
          | `Ties of ties (*tok*)
        ]
    )
      option
)

and from_clause = (from (*tok*) * join_clause)

and group_by_clause = (
    group (*tok*)
  * by (*tok*)
  * filename
  * (Token.t (* "," *) * filename) list (* zero or more *)
  * (having (*tok*) * filename) option
)

and join_clause = (
    table_or_subquery
  * (join_operator * table_or_subquery * join_constraint option)
      list (* zero or more *)
)

and join_constraint = [
    `On_expr of (on (*tok*) * filename)
  | `Using_LPAR_name_rep_COMMA_name_RPAR of (
        using (*tok*)
      * Token.t (* "(" *)
      * error_message
      * (Token.t (* "," *) * error_message) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

and limit_clause = (
    limit (*tok*)
  * filename
  * [
        `Offset_expr of (offset (*tok*) * filename)
      | `COMMA_expr of (Token.t (* "," *) * filename)
    ]
      option
)

and order_by_clause = (
    order (*tok*)
  * by (*tok*)
  * ordering_term
  * (Token.t (* "," *) * ordering_term) list (* zero or more *)
)

and ordering_term = (
    filename
  * anon_choice_asc_fa4fd8b option
  * (nulls (*tok*) * [ `First of first (*tok*) | `Last of last (*tok*) ])
      option
)

and over_clause = (
    over (*tok*)
  * [
        `Name of error_message
      | `LPAR_opt_name_opt_part_by_expr_rep_COMMA_expr_opt_order_by_orde_term_rep_COMMA_orde_term_opt_frame_spec_RPAR of
          window_defn
    ]
)

and result_column = [
    `Name_DOT_STAR of (error_message * Token.t (* "." *) * Token.t (* "*" *))
  | `STAR of Token.t (* "*" *)
  | `Expr_opt_opt_as_name of (filename * anon_opt_opt_as_error_mess_6e99511)
]

and select_core = [
    `Select_opt_choice_dist_result_column_rep_COMMA_result_column_opt_from_clause_opt_where_clause_opt_group_by_clause_opt_window_clause of (
        select (*tok*)
      * [ `Dist of distinct (*tok*) | `All of all (*tok*) ] option
      * result_column
      * (Token.t (* "," *) * result_column) list (* zero or more *)
      * from_clause option
      * where_clause option
      * group_by_clause option
      * window_clause option
    )
  | `Values_LPAR_expr_rep_COMMA_expr_RPAR_rep_COMMA_LPAR_expr_rep_COMMA_expr_RPAR of (
        values (*tok*)
      * Token.t (* "(" *)
      * filename
      * (Token.t (* "," *) * filename) list (* zero or more *)
      * Token.t (* ")" *)
      * anon_COMMA_LPAR_file_rep_COMMA_file_RPAR_a378f47
          list (* zero or more *)
    )
]

and select_stmt = [
  `Rectype of (
      with_clause option
    * select_core
    * (compound_operator * select_core) list (* zero or more *)
    * order_by_clause option
    * limit_clause option
  )
]

and table_or_subquery = [
    `Name2_opt_opt_as_name_opt_choice_inde_by_name of (
        name2
      * anon_opt_opt_as_error_mess_6e99511
      * anon_choice_inde_by_error_mess_0500888 option
    )
  | `Name2_LPAR_expr_rep_COMMA_expr_RPAR_opt_opt_as_name of (
        name2
      * Token.t (* "(" *)
      * filename
      * (Token.t (* "," *) * filename) list (* zero or more *)
      * Token.t (* ")" *)
      * anon_opt_opt_as_error_mess_6e99511
    )
  | `LPAR_select_stmt_RPAR_opt_opt_as_name of (
        Token.t (* "(" *) * select_stmt * Token.t (* ")" *)
      * anon_opt_opt_as_error_mess_6e99511
    )
  | `LPAR_join_clause_RPAR of (
        Token.t (* "(" *) * join_clause * Token.t (* ")" *)
    )
]

and where_clause = (where (*tok*) * filename)

and window_clause = (
    window (*tok*)
  * error_message
  * as_ (*tok*)
  * window_defn
  * (Token.t (* "," *) * error_message * as_ (*tok*) * window_defn)
      list (* zero or more *)
)

and window_defn = (
    Token.t (* "(" *)
  * error_message option
  * (
        partition (*tok*)
      * by (*tok*)
      * filename
      * (Token.t (* "," *) * filename) list (* zero or more *)
    )
      option
  * order_by_clause option
  * frame_spec option
  * Token.t (* ")" *)
)

and with_clause = [
  `Rectype of (
      with_ (*tok*)
    * recursive (*tok*) option
    * common_table_expression
    * (Token.t (* "," *) * common_table_expression) list (* zero or more *)
  )
]

type foreign_key_clause = (
    references (*tok*)
  * error_message
  * column_name_list option
  * [
        `On_choice_delete_choice_set_null of (
            on (*tok*)
          * [ `Delete of delete (*tok*) | `Update of update (*tok*) ]
          * [
                `Set_null of (set (*tok*) * null (*tok*))
              | `Set_defa of (set (*tok*) * default (*tok*))
              | `Casc of cascade (*tok*)
              | `Rest of restrict (*tok*)
              | `No_action of (no (*tok*) * action (*tok*))
            ]
        )
      | `Match_name of (match_ (*tok*) * error_message)
    ]
      list (* zero or more *)
  * (
        not (*tok*) option
      * deferrable (*tok*)
      * [
            `Init_defe of (initially (*tok*) * deferred (*tok*))
          | `Init_imme of (initially (*tok*) * immediate (*tok*))
        ]
          option
    )
      option
)

type indexed_column = (filename * anon_choice_asc_fa4fd8b option)

type attach_stmt = (
    attach (*tok*)
  * database (*tok*) option
  * filename
  * as_ (*tok*)
  * error_message
)

type vacuum_stmt = (
    vacuum (*tok*)
  * error_message option
  * (into (*tok*) * filename) option
)

type returning_clause = (
    returning (*tok*)
  * result_column
  * (Token.t (* "," *) * result_column) list (* zero or more *)
)

type create_view_stmt = (
    create (*tok*)
  * anon_choice_temp_716f4ac option
  * view (*tok*)
  * (if_ (*tok*) * not (*tok*) * exists (*tok*)) option
  * name2
  * column_name_list option
  * as_ (*tok*)
  * select_stmt
)

type column_constraint = (
    (constraint_ (*tok*) * error_message) option
  * [
        `Prim_key_opt_choice_asc_opt_conf_clause_opt_auto of (
            primary (*tok*)
          * key (*tok*)
          * anon_choice_asc_fa4fd8b option
          * conflict_clause option
          * autoincrement (*tok*) option
        )
      | `Opt_not_null_opt_conf_clause of (
            not (*tok*) option
          * null (*tok*)
          * conflict_clause option
        )
      | `Unique_opt_conf_clause of (unique (*tok*) * conflict_clause option)
      | `Check_LPAR_expr_RPAR of (
            check (*tok*) * Token.t (* "(" *) * filename * Token.t (* ")" *)
        )
      | `Defa_choice_LPAR_expr_RPAR of (
            default (*tok*)
          * [
                `LPAR_expr_RPAR of (
                    Token.t (* "(" *) * filename * Token.t (* ")" *)
                )
              | `Lit_value of literal_value
              | `Signed_num of signed_number
            ]
        )
      | `Coll_coll_name of (collate (*tok*) * collation_name)
      | `Fore_key_clause of foreign_key_clause
      | `Opt_gene_always_as_LPAR_expr_RPAR_opt_choice_stored of (
            (generated (*tok*) * always (*tok*)) option
          * as_ (*tok*)
          * Token.t (* "(" *)
          * filename
          * Token.t (* ")" *)
          * [ `Stored of stored (*tok*) | `Virt of virtual_ (*tok*) ] option
        )
    ]
)

type create_index_stmt = (
    create (*tok*)
  * unique (*tok*) option
  * index (*tok*)
  * (if_ (*tok*) * not (*tok*) * exists (*tok*)) option
  * name2
  * on (*tok*)
  * error_message
  * Token.t (* "(" *)
  * indexed_column
  * (Token.t (* "," *) * indexed_column) list (* zero or more *)
  * Token.t (* ")" *)
  * where_clause option
)

type table_constraint = (
    (constraint_ (*tok*) * error_message) option
  * [
        `Choice_prim_key_LPAR_inde_column_rep_COMMA_inde_column_RPAR_opt_conf_clause of (
            [
                `Prim_key of (primary (*tok*) * key (*tok*))
              | `Unique of unique (*tok*)
            ]
          * Token.t (* "(" *)
          * indexed_column
          * (Token.t (* "," *) * indexed_column) list (* zero or more *)
          * Token.t (* ")" *)
          * conflict_clause option
        )
      | `Check_LPAR_expr_RPAR of (
            check (*tok*) * Token.t (* "(" *) * filename * Token.t (* ")" *)
        )
      | `Fore_key_LPAR_name_rep_COMMA_name_RPAR_fore_key_clause of (
            foreign (*tok*)
          * key (*tok*)
          * Token.t (* "(" *)
          * error_message
          * (Token.t (* "," *) * error_message) list (* zero or more *)
          * Token.t (* ")" *)
          * foreign_key_clause
        )
    ]
)

type upsert_clause = (
    on (*tok*)
  * conflict (*tok*)
  * (
        Token.t (* "(" *)
      * indexed_column
      * (Token.t (* "," *) * indexed_column) list (* zero or more *)
      * Token.t (* ")" *)
      * where_clause option
    )
      option
  * do_ (*tok*)
  * [
        `Noth of nothing (*tok*)
      | `Update_set_choice_name_EQ_expr_rep_COMMA_choice_name_EQ_expr_opt_where_clause of (
            update (*tok*)
          * set (*tok*)
          * anon_choice_error_mess_facbc16
          * Token.t (* "=" *)
          * filename
          * (
                Token.t (* "," *) * anon_choice_error_mess_facbc16
              * Token.t (* "=" *) * filename
            )
              list (* zero or more *)
          * where_clause option
        )
    ]
)

type update_stmt = (
    with_clause option
  * update (*tok*)
  * (or_ (*tok*) * anon_choice_abort_500a898) option
  * qualified_table_name
  * set (*tok*)
  * anon_choice_error_mess_facbc16
  * Token.t (* "=" *)
  * filename
  * (
        Token.t (* "," *) * anon_choice_error_mess_facbc16
      * Token.t (* "=" *) * filename
    )
      list (* zero or more *)
  * from_clause option
  * where_clause option
  * returning_clause option
  * order_by_clause option
  * limit_clause option
)

type delete_stmt = (
    with_clause option
  * delete (*tok*)
  * from (*tok*)
  * qualified_table_name
  * where_clause option
  * returning_clause option
  * order_by_clause option
  * limit_clause option
)

type column_def = (
    error_message
  * type_name option
  * column_constraint list (* zero or more *)
)

type insert_stmt = (
    with_clause option
  * [
        `Repl of replace (*tok*)
      | `Insert_opt_or_choice_abort of (
            insert (*tok*)
          * (or_ (*tok*) * anon_choice_abort_500a898) option
        )
    ]
  * into (*tok*)
  * name2
  * (as_ (*tok*) * error_message) option
  * column_name_list option
  * [
        `Values_LPAR_expr_rep_COMMA_expr_RPAR_rep_COMMA_LPAR_expr_rep_COMMA_expr_RPAR_opt_upsert_clause of (
            values (*tok*)
          * Token.t (* "(" *)
          * filename
          * (Token.t (* "," *) * filename) list (* zero or more *)
          * Token.t (* ")" *)
          * anon_COMMA_LPAR_file_rep_COMMA_file_RPAR_a378f47
              list (* zero or more *)
          * upsert_clause option
        )
      | `Select_stmt_opt_upsert_clause of (
            select_stmt
          * upsert_clause option
        )
      | `Defa_values of (default (*tok*) * values (*tok*))
    ]
  * returning_clause option
)

type create_virtual_table_stmt = (
    create (*tok*)
  * virtual_ (*tok*)
  * table (*tok*)
  * (if_ (*tok*) * not (*tok*) * exists (*tok*)) option
  * name2
  * using (*tok*)
  * error_message
  * (
        Token.t (* "(" *)
      * column_def
      * (Token.t (* "," *) * column_def) list (* zero or more *)
      * (Token.t (* "," *) * table_constraint) list (* zero or more *)
      * Token.t (* ")" *)
    )
      option
)

type create_table_stmt = (
    create (*tok*)
  * anon_choice_temp_716f4ac option
  * table (*tok*)
  * (if_ (*tok*) * not (*tok*) * exists (*tok*)) option
  * name2
  * [
        `As_select_stmt of (as_ (*tok*) * select_stmt)
      | `LPAR_column_def_rep_COMMA_column_def_rep_COMMA_table_cons_RPAR_opt_with_rowid of (
            Token.t (* "(" *)
          * column_def
          * (Token.t (* "," *) * column_def) list (* zero or more *)
          * (Token.t (* "," *) * table_constraint) list (* zero or more *)
          * Token.t (* ")" *)
          * (without (*tok*) * rowid (*tok*)) option
        )
    ]
)

type alter_table_stmt = (
    alter (*tok*)
  * table (*tok*)
  * name2
  * [
        `Rename_to_name of (rename (*tok*) * to_ (*tok*) * error_message)
      | `Rename_opt_column_name_to_name of (
            rename (*tok*)
          * column (*tok*) option
          * error_message
          * to_ (*tok*)
          * error_message
        )
      | `Add_opt_column_column_def of (
            add (*tok*)
          * column (*tok*) option
          * column_def
        )
      | `Drop_opt_column_name of (
            drop (*tok*)
          * column (*tok*) option
          * error_message
        )
    ]
)

type create_trigger_stmt = (
    create (*tok*)
  * anon_choice_temp_716f4ac option
  * trigger (*tok*)
  * (if_ (*tok*) * not (*tok*) * exists (*tok*)) option
  * name2
  * [
        `Before of before (*tok*)
      | `After of after (*tok*)
      | `Inst_of of (instead (*tok*) * of_ (*tok*))
    ]
      option
  * [
        `Delete of delete (*tok*)
      | `Insert of insert (*tok*)
      | `Update_opt_of_name_rep_COMMA_name of (
            update (*tok*)
          * (
                of_ (*tok*)
              * error_message
              * (Token.t (* "," *) * error_message) list (* zero or more *)
            )
              option
        )
    ]
  * on (*tok*)
  * error_message
  * [
        `For_each_row_opt_when_expr of (
            for_ (*tok*)
          * each (*tok*)
          * row (*tok*)
          * (when_ (*tok*) * filename) option
        )
      | `When_expr of (when_ (*tok*) * filename)
    ]
      option
  * begin_ (*tok*)
  * (
        [
            `Update_stmt of update_stmt
          | `Insert_stmt of insert_stmt
          | `Delete_stmt of delete_stmt
          | `Select_stmt of select_stmt
        ]
      * Token.t (* ";" *)
    )
      list (* one or more *)
  * end_ (*tok*)
)

type sql_stmt = (
    (explain (*tok*) * (query (*tok*) * plan (*tok*)) option) option
  * [
        `Alter_table_stmt of alter_table_stmt
      | `Anal_stmt of analyze_stmt
      | `Attach_stmt of attach_stmt
      | `Begin_stmt of begin_stmt
      | `Commit_stmt of commit_stmt
      | `Create_index_stmt of create_index_stmt
      | `Create_table_stmt of create_table_stmt
      | `Create_trig_stmt of create_trigger_stmt
      | `Create_view_stmt of create_view_stmt
      | `Create_virt_table_stmt of create_virtual_table_stmt
      | `Delete_stmt of delete_stmt
      | `Detach_stmt of detach_stmt
      | `Drop_index_stmt of drop_index_stmt
      | `Drop_table_stmt of drop_table_stmt
      | `Drop_trig_stmt of drop_trigger_stmt
      | `Drop_view_stmt of drop_view_stmt
      | `Insert_stmt of insert_stmt
      | `Pragma_stmt of pragma_stmt
      | `Rein_stmt of reindex_stmt
      | `Rele_stmt of release_stmt
      | `Roll_stmt of rollback_stmt
      | `Save_stmt of savepoint_stmt
      | `Select_stmt of select_stmt
      | `Update_stmt of update_stmt
      | `Vacuum_stmt of vacuum_stmt
    ]
)

type sql_stmt_list = (
    sql_stmt option
  * (Token.t (* ";" *) * sql_stmt option) list (* zero or more *)
)

type whitespace (* inlined *) = Token.t (* pattern [ \t\n\f\r]+ *)

type word (* inlined *) =
  Token.t (* pattern [_a-zA-Z\x80-\xFF$@#:?][$_0-9a-zA-Z\x80-\xFF]* *)

type comment (* inlined *) = [
    `DASHDASH_pat_4fd4a56 of (Token.t (* "--" *) * pat_4fd4a56)
  | `SLASHSTAR_pat_05bf793_SLASH of (
        Token.t (* "/*" *) * pat_05bf793 * Token.t (* "/" *)
    )
]

type blob_literal (* inlined *) = (
    [ `X_9dd4e46 of Token.t (* "x" *) | `X_02129bb of Token.t (* "X" *) ]
  * string_literal
)

type raise_function (* inlined *) = (
    raise (*tok*)
  * Token.t (* "(" *)
  * [
        `Ignore of ignore (*tok*)
      | `Choice_roll_COMMA_error_mess of (
            [
                `Roll of rollback (*tok*)
              | `Abort of abort (*tok*)
              | `Fail of fail (*tok*)
            ]
          * Token.t (* "," *)
          * error_message
        )
    ]
  * Token.t (* ")" *)
)
