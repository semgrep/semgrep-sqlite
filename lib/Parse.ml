(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_sqlite"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "whitespace";
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "nulls", None;
  "current_time", None;
  "into", None;
  "insert", None;
  "numeric_literal", None;
  "cast", None;
  "current_date", None;
  "database", None;
  "all", None;
  "unique", None;
  "do", None;
  "inner", None;
  "temp", None;
  "initially", None;
  "instead", None;
  "join", None;
  "pat_93c883a", None;
  "autoincrement", None;
  "first", None;
  "on", None;
  "generated", None;
  "set", None;
  "delete", None;
  "false", None;
  "asc", None;
  "pat_213dc3e", None;
  "replace", None;
  "virtual", None;
  "else", None;
  "vacuum", None;
  "analyze", None;
  "recursive", None;
  "update", None;
  "using", None;
  "ignore", None;
  "trigger", None;
  "deferrable", None;
  "fail", None;
  "no", None;
  "pat_05bf793", None;
  "action", None;
  "filter", None;
  "null", None;
  "cascade", None;
  "explain", None;
  "end", None;
  "range", None;
  "after", None;
  "or", None;
  "before", None;
  "case", None;
  "is", None;
  "temporary", None;
  "rename", None;
  "exists", None;
  "of", None;
  "each", None;
  "query", None;
  "window", None;
  "foreign", None;
  "indexed", None;
  "check", None;
  "in", None;
  "with", None;
  "as", None;
  "order", None;
  "attach", None;
  "drop", None;
  "rows", None;
  "current_timestamp", None;
  "intersect", None;
  "pat_bb5937d", None;
  "ties", None;
  "where", None;
  "not", None;
  "pat_4fd4a56", None;
  "between", None;
  "begin", None;
  "glob", None;
  "rollback", None;
  "constraint", None;
  "union", None;
  "when", None;
  "deferred", None;
  "limit", None;
  "offset", None;
  "isnull", None;
  "to", None;
  "view", None;
  "pragma", None;
  "detach", None;
  "release", None;
  "table", None;
  "references", None;
  "true", None;
  "pat_29ffae5", None;
  "pat_73398bc", None;
  "like", None;
  "outer", None;
  "collate", None;
  "primary", None;
  "raise", None;
  "transaction", None;
  "conflict", None;
  "distinct", None;
  "whitespace", None;
  "from", None;
  "key", None;
  "over", None;
  "desc", None;
  "for", None;
  "returning", None;
  "commit", None;
  "exclude", None;
  "exclusive", None;
  "natural", None;
  "current", None;
  "restrict", None;
  "notnull", None;
  "partition", None;
  "pat_f154b4a", None;
  "by", None;
  "without", None;
  "default", None;
  "pat_f79575e", None;
  "then", None;
  "cross", None;
  "except", None;
  "alter", None;
  "group", None;
  "materialized", None;
  "stored", None;
  "immediate", None;
  "regexp", None;
  "reindex", None;
  "escape", None;
  "index", None;
  "last", None;
  "having", None;
  "match", None;
  "rowid", None;
  "create", None;
  "if", None;
  "plan", None;
  "unbounded", None;
  "groups", None;
  "left", None;
  "and", None;
  "abort", None;
  "others", None;
  "preceding", None;
  "savepoint", None;
  "following", None;
  "values", None;
  "always", None;
  "row", None;
  "column", None;
  "nothing", None;
  "select", None;
  "add", None;
  "signed_number",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Literal "+");
          Token (Literal "-");
        |];
      );
      Token (Name "numeric_literal");
    ];
  );
  "bind_parameter",
  Some (
    Alt [|
      Seq [
        Token (Literal "?");
        Repeat (
          Token (Name "pat_213dc3e");
        );
      ];
      Seq [
        Alt [|
          Token (Literal "@");
          Token (Literal "$");
          Token (Literal ":");
          Token (Literal "#");
        |];
        Token (Name "pat_93c883a");
      ];
    |];
  );
  "comment",
  Some (
    Alt [|
      Seq [
        Token (Literal "--");
        Token (Name "pat_4fd4a56");
      ];
      Seq [
        Token (Literal "/*");
        Token (Name "pat_05bf793");
        Token (Literal "/");
      ];
    |];
  );
  "identifier",
  Some (
    Alt [|
      Token (Name "pat_29ffae5");
      Seq [
        Token (Literal "\"");
        Token (Name "pat_73398bc");
        Token (Literal "\"");
      ];
      Seq [
        Token (Literal "`");
        Token (Name "pat_bb5937d");
        Token (Literal "`");
      ];
      Seq [
        Token (Literal "[");
        Token (Name "pat_f154b4a");
        Token (Literal "]");
      ];
    |];
  );
  "string",
  Some (
    Seq [
      Token (Literal "'");
      Token (Name "pat_f79575e");
      Token (Literal "'");
    ];
  );
  "compound_operator",
  Some (
    Alt [|
      Token (Name "union");
      Seq [
        Token (Name "union");
        Token (Name "all");
      ];
      Token (Name "intersect");
      Token (Name "except");
    |];
  );
  "join_operator",
  Some (
    Alt [|
      Token (Literal ",");
      Seq [
        Opt (
          Token (Name "natural");
        );
        Opt (
          Alt [|
            Seq [
              Token (Name "left");
              Opt (
                Token (Name "outer");
              );
            ];
            Token (Name "inner");
            Token (Name "cross");
          |];
        );
        Token (Name "join");
      ];
    |];
  );
  "conflict_clause",
  Some (
    Seq [
      Token (Name "on");
      Token (Name "conflict");
      Alt [|
        Token (Name "rollback");
        Token (Name "abort");
        Token (Name "fail");
        Token (Name "ignore");
        Token (Name "replace");
      |];
    ];
  );
  "function_name", Some (Token (Name "identifier"););
  "blob_literal",
  Some (
    Seq [
      Alt [|
        Token (Literal "x");
        Token (Literal "X");
      |];
      Token (Name "string");
    ];
  );
  "string_literal", Some (Token (Name "string"););
  "name",
  Some (
    Alt [|
      Token (Name "string_literal");
      Token (Name "identifier");
    |];
  );
  "literal_value",
  Some (
    Alt [|
      Token (Name "numeric_literal");
      Token (Name "string_literal");
      Token (Name "blob_literal");
      Token (Name "null");
      Token (Name "true");
      Token (Name "false");
      Token (Name "current_time");
      Token (Name "current_date");
      Token (Name "current_timestamp");
    |];
  );
  "collation_name",
  Some (
    Alt [|
      Token (Name "string_literal");
      Token (Name "identifier");
    |];
  );
  "begin_stmt",
  Some (
    Seq [
      Token (Name "begin");
      Opt (
        Alt [|
          Token (Name "deferred");
          Token (Name "immediate");
          Token (Name "exclusive");
        |];
      );
      Opt (
        Seq [
          Token (Name "transaction");
          Opt (
            Token (Name "name");
          );
        ];
      );
    ];
  );
  "release_stmt",
  Some (
    Seq [
      Token (Name "release");
      Opt (
        Token (Name "savepoint");
      );
      Token (Name "name");
    ];
  );
  "pragma_value",
  Some (
    Alt [|
      Token (Name "signed_number");
      Token (Name "name");
    |];
  );
  "type_name",
  Some (
    Seq [
      Repeat1 (
        Token (Name "name");
      );
      Opt (
        Alt [|
          Seq [
            Token (Literal "(");
            Token (Name "signed_number");
            Token (Literal ")");
          ];
          Seq [
            Token (Literal "(");
            Token (Name "signed_number");
            Token (Literal ",");
            Token (Name "signed_number");
            Token (Literal ")");
          ];
        |];
      );
    ];
  );
  "name2",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "name");
          Token (Literal ".");
        ];
      );
      Token (Name "name");
    ];
  );
  "column_name_list",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "name");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "name");
        ];
      );
      Token (Literal ")");
    ];
  );
  "detach_stmt",
  Some (
    Seq [
      Token (Name "detach");
      Opt (
        Token (Name "database");
      );
      Token (Name "name");
    ];
  );
  "savepoint_stmt",
  Some (
    Seq [
      Token (Name "savepoint");
      Token (Name "name");
    ];
  );
  "error_message", Some (Token (Name "name"););
  "rollback_stmt",
  Some (
    Seq [
      Token (Name "rollback");
      Opt (
        Seq [
          Token (Name "transaction");
          Opt (
            Token (Name "name");
          );
        ];
      );
      Opt (
        Seq [
          Token (Name "to");
          Opt (
            Token (Name "savepoint");
          );
          Token (Name "name");
        ];
      );
    ];
  );
  "commit_stmt",
  Some (
    Seq [
      Alt [|
        Token (Name "commit");
        Token (Name "end");
      |];
      Opt (
        Seq [
          Token (Name "transaction");
          Opt (
            Token (Name "name");
          );
        ];
      );
    ];
  );
  "foreign_key_clause",
  Some (
    Seq [
      Token (Name "references");
      Token (Name "name");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "name");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "name");
            ];
          );
          Token (Literal ")");
        ];
      );
      Repeat (
        Alt [|
          Seq [
            Token (Name "on");
            Alt [|
              Token (Name "delete");
              Token (Name "update");
            |];
            Alt [|
              Seq [
                Token (Name "set");
                Token (Name "null");
              ];
              Seq [
                Token (Name "set");
                Token (Name "default");
              ];
              Token (Name "cascade");
              Token (Name "restrict");
              Seq [
                Token (Name "no");
                Token (Name "action");
              ];
            |];
          ];
          Seq [
            Token (Name "match");
            Token (Name "name");
          ];
        |];
      );
      Opt (
        Seq [
          Opt (
            Token (Name "not");
          );
          Token (Name "deferrable");
          Opt (
            Alt [|
              Seq [
                Token (Name "initially");
                Token (Name "deferred");
              ];
              Seq [
                Token (Name "initially");
                Token (Name "immediate");
              ];
            |];
          );
        ];
      );
    ];
  );
  "reindex_stmt",
  Some (
    Seq [
      Token (Name "reindex");
      Opt (
        Token (Name "name2");
      );
    ];
  );
  "analyze_stmt",
  Some (
    Seq [
      Token (Name "analyze");
      Opt (
        Token (Name "name2");
      );
    ];
  );
  "drop_view_stmt",
  Some (
    Seq [
      Token (Name "drop");
      Token (Name "view");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
    ];
  );
  "qualified_table_name",
  Some (
    Seq [
      Token (Name "name2");
      Opt (
        Seq [
          Token (Name "as");
          Token (Name "name");
        ];
      );
      Opt (
        Alt [|
          Seq [
            Token (Name "indexed");
            Token (Name "by");
            Token (Name "name");
          ];
          Seq [
            Token (Name "not");
            Token (Name "indexed");
          ];
        |];
      );
    ];
  );
  "pragma_stmt",
  Some (
    Seq [
      Token (Name "pragma");
      Token (Name "name2");
      Opt (
        Alt [|
          Seq [
            Token (Literal "=");
            Token (Name "pragma_value");
          ];
          Seq [
            Token (Literal "(");
            Token (Name "pragma_value");
            Token (Literal ")");
          ];
        |];
      );
    ];
  );
  "drop_table_stmt",
  Some (
    Seq [
      Token (Name "drop");
      Token (Name "table");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
    ];
  );
  "drop_index_stmt",
  Some (
    Seq [
      Token (Name "drop");
      Token (Name "index");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
    ];
  );
  "drop_trigger_stmt",
  Some (
    Seq [
      Token (Name "drop");
      Token (Name "trigger");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
    ];
  );
  "raise_function",
  Some (
    Seq [
      Token (Name "raise");
      Token (Literal "(");
      Alt [|
        Token (Name "ignore");
        Seq [
          Alt [|
            Token (Name "rollback");
            Token (Name "abort");
            Token (Name "fail");
          |];
          Token (Literal ",");
          Token (Name "error_message");
        ];
      |];
      Token (Literal ")");
    ];
  );
  "common_table_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "name");
        Opt (
          Seq [
            Token (Literal "(");
            Token (Name "name");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "name");
              ];
            );
            Token (Literal ")");
          ];
        );
        Token (Name "as");
        Opt (
          Seq [
            Opt (
              Token (Name "not");
            );
            Token (Name "materialized");
          ];
        );
        Token (Literal "(");
        Token (Name "select_stmt");
        Token (Literal ")");
      ];
    |];
  );
  "expr",
  Some (
    Alt [|
      Token (Name "literal_value");
      Token (Name "bind_parameter");
      Token (Name "name");
      Seq [
        Token (Name "name");
        Token (Literal ".");
        Token (Name "name");
      ];
      Seq [
        Token (Name "name");
        Token (Literal ".");
        Token (Name "name");
        Token (Literal ".");
        Token (Name "name");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expr");
      ];
      Seq [
        Alt [|
          Token (Literal "-");
          Token (Literal "+");
        |];
        Token (Name "expr");
      ];
      Seq [
        Token (Name "not");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Literal "||");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Alt [|
          Token (Literal "*");
          Token (Literal "/");
          Token (Literal "%");
        |];
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Alt [|
          Token (Literal "+");
          Token (Literal "-");
        |];
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Alt [|
          Token (Literal "<<");
          Token (Literal ">>");
          Token (Literal "&");
          Token (Literal "|");
        |];
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Alt [|
          Token (Literal "<");
          Token (Literal "<=");
          Token (Literal ">");
          Token (Literal ">=");
        |];
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Alt [|
          Token (Literal "=");
          Token (Literal "==");
          Token (Literal "!=");
          Token (Literal "<>");
        |];
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Opt (
          Token (Name "not");
        );
        Token (Name "in");
        Alt [|
          Seq [
            Token (Literal "(");
            Opt (
              Alt [|
                Token (Name "select_stmt");
                Seq [
                  Token (Name "expr");
                  Repeat (
                    Seq [
                      Token (Literal ",");
                      Token (Name "expr");
                    ];
                  );
                ];
              |];
            );
            Token (Literal ")");
          ];
          Seq [
            Token (Name "name2");
            Opt (
              Seq [
                Token (Literal "(");
                Opt (
                  Seq [
                    Token (Name "expr");
                    Repeat (
                      Seq [
                        Token (Literal ",");
                        Token (Name "expr");
                      ];
                    );
                  ];
                );
                Token (Literal ")");
              ];
            );
          ];
        |];
      ];
      Seq [
        Token (Name "expr");
        Token (Name "and");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "or");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "function_name");
        Token (Literal "(");
        Opt (
          Alt [|
            Seq [
              Opt (
                Token (Name "distinct");
              );
              Token (Name "expr");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "expr");
                ];
              );
            ];
            Token (Literal "*");
          |];
        );
        Token (Literal ")");
        Opt (
          Token (Name "filter_clause");
        );
        Opt (
          Token (Name "over_clause");
        );
      ];
      Seq [
        Token (Literal "(");
        Token (Name "expr");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expr");
          ];
        );
        Token (Literal ")");
      ];
      Seq [
        Token (Name "cast");
        Token (Literal "(");
        Token (Name "expr");
        Token (Name "as");
        Token (Name "type_name");
        Token (Literal ")");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "collate");
        Token (Name "collation_name");
      ];
      Seq [
        Token (Name "expr");
        Opt (
          Token (Name "not");
        );
        Alt [|
          Token (Name "like");
          Token (Name "glob");
          Token (Name "regexp");
          Token (Name "match");
        |];
        Token (Name "expr");
        Opt (
          Seq [
            Token (Name "escape");
            Token (Name "expr");
          ];
        );
      ];
      Seq [
        Token (Name "expr");
        Alt [|
          Token (Name "isnull");
          Token (Name "notnull");
          Seq [
            Token (Name "not");
            Token (Name "null");
          ];
        |];
      ];
      Seq [
        Token (Name "expr");
        Token (Name "is");
        Opt (
          Token (Name "not");
        );
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Opt (
          Token (Name "not");
        );
        Token (Name "between");
        Token (Name "expr");
        Token (Name "and");
        Token (Name "expr");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "select_stmt");
        Token (Literal ")");
      ];
      Seq [
        Token (Name "exists");
        Token (Literal "(");
        Token (Name "select_stmt");
        Token (Literal ")");
      ];
      Seq [
        Token (Name "not");
        Token (Name "exists");
        Token (Literal "(");
        Token (Name "select_stmt");
        Token (Literal ")");
      ];
      Seq [
        Token (Name "case");
        Opt (
          Token (Name "expr");
        );
        Repeat1 (
          Seq [
            Token (Name "when");
            Token (Name "expr");
            Token (Name "then");
            Token (Name "expr");
          ];
        );
        Opt (
          Seq [
            Token (Name "else");
            Token (Name "expr");
          ];
        );
        Token (Name "end");
      ];
      Token (Name "raise_function");
    |];
  );
  "filter_clause",
  Some (
    Seq [
      Token (Name "filter");
      Token (Literal "(");
      Token (Name "where");
      Token (Name "expr");
      Token (Literal ")");
    ];
  );
  "frame_spec",
  Some (
    Seq [
      Alt [|
        Token (Name "range");
        Token (Name "rows");
        Token (Name "groups");
      |];
      Alt [|
        Seq [
          Token (Name "between");
          Alt [|
            Seq [
              Token (Name "unbounded");
              Token (Name "preceding");
            ];
            Seq [
              Token (Name "expr");
              Token (Name "preceding");
            ];
            Seq [
              Token (Name "current");
              Token (Name "row");
            ];
            Seq [
              Token (Name "expr");
              Token (Name "following");
            ];
          |];
          Token (Name "and");
          Alt [|
            Seq [
              Token (Name "expr");
              Token (Name "preceding");
            ];
            Seq [
              Token (Name "current");
              Token (Name "row");
            ];
            Seq [
              Token (Name "expr");
              Token (Name "following");
            ];
            Seq [
              Token (Name "unbounded");
              Token (Name "following");
            ];
          |];
        ];
        Seq [
          Token (Name "unbounded");
          Token (Name "preceding");
        ];
        Seq [
          Token (Name "expr");
          Token (Name "preceding");
        ];
        Seq [
          Token (Name "current");
          Token (Name "row");
        ];
      |];
      Opt (
        Seq [
          Token (Name "exclude");
          Alt [|
            Seq [
              Token (Name "not");
              Token (Name "others");
            ];
            Seq [
              Token (Name "current");
              Token (Name "row");
            ];
            Token (Name "group");
            Token (Name "ties");
          |];
        ];
      );
    ];
  );
  "from_clause",
  Some (
    Seq [
      Token (Name "from");
      Token (Name "join_clause");
    ];
  );
  "group_by_clause",
  Some (
    Seq [
      Token (Name "group");
      Token (Name "by");
      Token (Name "expr");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expr");
        ];
      );
      Opt (
        Seq [
          Token (Name "having");
          Token (Name "expr");
        ];
      );
    ];
  );
  "join_clause",
  Some (
    Seq [
      Token (Name "table_or_subquery");
      Repeat (
        Seq [
          Token (Name "join_operator");
          Token (Name "table_or_subquery");
          Opt (
            Token (Name "join_constraint");
          );
        ];
      );
    ];
  );
  "join_constraint",
  Some (
    Alt [|
      Seq [
        Token (Name "on");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "using");
        Token (Literal "(");
        Token (Name "name");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "name");
          ];
        );
        Token (Literal ")");
      ];
    |];
  );
  "limit_clause",
  Some (
    Seq [
      Token (Name "limit");
      Token (Name "expr");
      Opt (
        Alt [|
          Seq [
            Token (Name "offset");
            Token (Name "expr");
          ];
          Seq [
            Token (Literal ",");
            Token (Name "expr");
          ];
        |];
      );
    ];
  );
  "order_by_clause",
  Some (
    Seq [
      Token (Name "order");
      Token (Name "by");
      Token (Name "ordering_term");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "ordering_term");
        ];
      );
    ];
  );
  "ordering_term",
  Some (
    Seq [
      Token (Name "expr");
      Opt (
        Alt [|
          Token (Name "asc");
          Token (Name "desc");
        |];
      );
      Opt (
        Seq [
          Token (Name "nulls");
          Alt [|
            Token (Name "first");
            Token (Name "last");
          |];
        ];
      );
    ];
  );
  "over_clause",
  Some (
    Seq [
      Token (Name "over");
      Alt [|
        Token (Name "name");
        Seq [
          Token (Literal "(");
          Opt (
            Token (Name "name");
          );
          Opt (
            Seq [
              Token (Name "partition");
              Token (Name "by");
              Token (Name "expr");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "expr");
                ];
              );
            ];
          );
          Opt (
            Seq [
              Token (Name "order");
              Token (Name "by");
              Token (Name "ordering_term");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "ordering_term");
                ];
              );
            ];
          );
          Opt (
            Token (Name "frame_spec");
          );
          Token (Literal ")");
        ];
      |];
    ];
  );
  "result_column",
  Some (
    Alt [|
      Seq [
        Token (Name "name");
        Token (Literal ".");
        Token (Literal "*");
      ];
      Token (Literal "*");
      Seq [
        Token (Name "expr");
        Opt (
          Seq [
            Opt (
              Token (Name "as");
            );
            Token (Name "name");
          ];
        );
      ];
    |];
  );
  "select_core",
  Some (
    Alt [|
      Seq [
        Token (Name "select");
        Opt (
          Alt [|
            Token (Name "distinct");
            Token (Name "all");
          |];
        );
        Token (Name "result_column");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "result_column");
          ];
        );
        Opt (
          Token (Name "from_clause");
        );
        Opt (
          Token (Name "where_clause");
        );
        Opt (
          Token (Name "group_by_clause");
        );
        Opt (
          Token (Name "window_clause");
        );
      ];
      Seq [
        Token (Name "values");
        Token (Literal "(");
        Token (Name "expr");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expr");
          ];
        );
        Token (Literal ")");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Literal "(");
            Token (Name "expr");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expr");
              ];
            );
            Token (Literal ")");
          ];
        );
      ];
    |];
  );
  "select_stmt",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "with_clause");
        );
        Token (Name "select_core");
        Repeat (
          Seq [
            Token (Name "compound_operator");
            Token (Name "select_core");
          ];
        );
        Opt (
          Token (Name "order_by_clause");
        );
        Opt (
          Token (Name "limit_clause");
        );
      ];
    |];
  );
  "table_or_subquery",
  Some (
    Alt [|
      Seq [
        Token (Name "name2");
        Opt (
          Seq [
            Opt (
              Token (Name "as");
            );
            Token (Name "name");
          ];
        );
        Opt (
          Alt [|
            Seq [
              Token (Name "indexed");
              Token (Name "by");
              Token (Name "name");
            ];
            Seq [
              Token (Name "not");
              Token (Name "indexed");
            ];
          |];
        );
      ];
      Seq [
        Token (Name "name2");
        Token (Literal "(");
        Token (Name "expr");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expr");
          ];
        );
        Token (Literal ")");
        Opt (
          Seq [
            Opt (
              Token (Name "as");
            );
            Token (Name "name");
          ];
        );
      ];
      Seq [
        Token (Literal "(");
        Token (Name "select_stmt");
        Token (Literal ")");
        Opt (
          Seq [
            Opt (
              Token (Name "as");
            );
            Token (Name "name");
          ];
        );
      ];
      Seq [
        Token (Literal "(");
        Token (Name "join_clause");
        Token (Literal ")");
      ];
    |];
  );
  "where_clause",
  Some (
    Seq [
      Token (Name "where");
      Token (Name "expr");
    ];
  );
  "window_clause",
  Some (
    Seq [
      Token (Name "window");
      Token (Name "name");
      Token (Name "as");
      Token (Name "window_defn");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "name");
          Token (Name "as");
          Token (Name "window_defn");
        ];
      );
    ];
  );
  "window_defn",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "name");
      );
      Opt (
        Seq [
          Token (Name "partition");
          Token (Name "by");
          Token (Name "expr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expr");
            ];
          );
        ];
      );
      Opt (
        Seq [
          Token (Name "order");
          Token (Name "by");
          Token (Name "ordering_term");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "ordering_term");
            ];
          );
        ];
      );
      Opt (
        Token (Name "frame_spec");
      );
      Token (Literal ")");
    ];
  );
  "with_clause",
  Some (
    Alt [|
      Seq [
        Token (Name "with");
        Opt (
          Token (Name "recursive");
        );
        Token (Name "common_table_expression");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "common_table_expression");
          ];
        );
      ];
    |];
  );
  "filename", Some (Token (Name "expr"););
  "column_constraint",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "constraint");
          Token (Name "name");
        ];
      );
      Alt [|
        Seq [
          Token (Name "primary");
          Token (Name "key");
          Opt (
            Alt [|
              Token (Name "asc");
              Token (Name "desc");
            |];
          );
          Opt (
            Token (Name "conflict_clause");
          );
          Opt (
            Token (Name "autoincrement");
          );
        ];
        Seq [
          Opt (
            Token (Name "not");
          );
          Token (Name "null");
          Opt (
            Token (Name "conflict_clause");
          );
        ];
        Seq [
          Token (Name "unique");
          Opt (
            Token (Name "conflict_clause");
          );
        ];
        Seq [
          Token (Name "check");
          Token (Literal "(");
          Token (Name "expr");
          Token (Literal ")");
        ];
        Seq [
          Token (Name "default");
          Alt [|
            Seq [
              Token (Literal "(");
              Token (Name "expr");
              Token (Literal ")");
            ];
            Token (Name "literal_value");
            Token (Name "signed_number");
          |];
        ];
        Seq [
          Token (Name "collate");
          Token (Name "collation_name");
        ];
        Token (Name "foreign_key_clause");
        Seq [
          Opt (
            Seq [
              Token (Name "generated");
              Token (Name "always");
            ];
          );
          Token (Name "as");
          Token (Literal "(");
          Token (Name "expr");
          Token (Literal ")");
          Opt (
            Alt [|
              Token (Name "stored");
              Token (Name "virtual");
            |];
          );
        ];
      |];
    ];
  );
  "attach_stmt",
  Some (
    Seq [
      Token (Name "attach");
      Opt (
        Token (Name "database");
      );
      Token (Name "expr");
      Token (Name "as");
      Token (Name "name");
    ];
  );
  "indexed_column",
  Some (
    Seq [
      Token (Name "expr");
      Opt (
        Alt [|
          Token (Name "asc");
          Token (Name "desc");
        |];
      );
    ];
  );
  "create_view_stmt",
  Some (
    Seq [
      Token (Name "create");
      Opt (
        Alt [|
          Token (Name "temp");
          Token (Name "temporary");
        |];
      );
      Token (Name "view");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "not");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "name");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "name");
            ];
          );
          Token (Literal ")");
        ];
      );
      Token (Name "as");
      Token (Name "select_stmt");
    ];
  );
  "returning_clause",
  Some (
    Seq [
      Token (Name "returning");
      Token (Name "result_column");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "result_column");
        ];
      );
    ];
  );
  "vacuum_stmt",
  Some (
    Seq [
      Token (Name "vacuum");
      Opt (
        Token (Name "name");
      );
      Opt (
        Seq [
          Token (Name "into");
          Token (Name "filename");
        ];
      );
    ];
  );
  "column_def",
  Some (
    Seq [
      Token (Name "name");
      Opt (
        Token (Name "type_name");
      );
      Repeat (
        Token (Name "column_constraint");
      );
    ];
  );
  "table_constraint",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "constraint");
          Token (Name "name");
        ];
      );
      Alt [|
        Seq [
          Alt [|
            Seq [
              Token (Name "primary");
              Token (Name "key");
            ];
            Token (Name "unique");
          |];
          Token (Literal "(");
          Token (Name "indexed_column");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "indexed_column");
            ];
          );
          Token (Literal ")");
          Opt (
            Token (Name "conflict_clause");
          );
        ];
        Seq [
          Token (Name "check");
          Token (Literal "(");
          Token (Name "expr");
          Token (Literal ")");
        ];
        Seq [
          Token (Name "foreign");
          Token (Name "key");
          Token (Literal "(");
          Token (Name "name");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "name");
            ];
          );
          Token (Literal ")");
          Token (Name "foreign_key_clause");
        ];
      |];
    ];
  );
  "upsert_clause",
  Some (
    Seq [
      Token (Name "on");
      Token (Name "conflict");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "indexed_column");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "indexed_column");
            ];
          );
          Token (Literal ")");
          Opt (
            Token (Name "where_clause");
          );
        ];
      );
      Token (Name "do");
      Alt [|
        Token (Name "nothing");
        Seq [
          Token (Name "update");
          Token (Name "set");
          Alt [|
            Token (Name "name");
            Token (Name "column_name_list");
          |];
          Token (Literal "=");
          Token (Name "expr");
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "name");
                Token (Name "column_name_list");
              |];
              Token (Literal "=");
              Token (Name "expr");
            ];
          );
          Opt (
            Token (Name "where_clause");
          );
        ];
      |];
    ];
  );
  "create_index_stmt",
  Some (
    Seq [
      Token (Name "create");
      Opt (
        Token (Name "unique");
      );
      Token (Name "index");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "not");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
      Token (Name "on");
      Token (Name "name");
      Token (Literal "(");
      Token (Name "indexed_column");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "indexed_column");
        ];
      );
      Token (Literal ")");
      Opt (
        Token (Name "where_clause");
      );
    ];
  );
  "delete_stmt",
  Some (
    Seq [
      Opt (
        Token (Name "with_clause");
      );
      Token (Name "delete");
      Token (Name "from");
      Token (Name "qualified_table_name");
      Opt (
        Token (Name "where_clause");
      );
      Opt (
        Token (Name "returning_clause");
      );
      Opt (
        Token (Name "order_by_clause");
      );
      Opt (
        Token (Name "limit_clause");
      );
    ];
  );
  "update_stmt",
  Some (
    Seq [
      Opt (
        Token (Name "with_clause");
      );
      Token (Name "update");
      Opt (
        Seq [
          Token (Name "or");
          Alt [|
            Token (Name "abort");
            Token (Name "fail");
            Token (Name "ignore");
            Token (Name "replace");
            Token (Name "rollback");
          |];
        ];
      );
      Token (Name "qualified_table_name");
      Token (Name "set");
      Alt [|
        Token (Name "name");
        Token (Name "column_name_list");
      |];
      Token (Literal "=");
      Token (Name "expr");
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "name");
            Token (Name "column_name_list");
          |];
          Token (Literal "=");
          Token (Name "expr");
        ];
      );
      Opt (
        Token (Name "from_clause");
      );
      Opt (
        Token (Name "where_clause");
      );
      Opt (
        Token (Name "returning_clause");
      );
      Opt (
        Token (Name "order_by_clause");
      );
      Opt (
        Token (Name "limit_clause");
      );
    ];
  );
  "alter_table_stmt",
  Some (
    Seq [
      Token (Name "alter");
      Token (Name "table");
      Token (Name "name2");
      Alt [|
        Seq [
          Token (Name "rename");
          Token (Name "to");
          Token (Name "name");
        ];
        Seq [
          Token (Name "rename");
          Opt (
            Token (Name "column");
          );
          Token (Name "name");
          Token (Name "to");
          Token (Name "name");
        ];
        Seq [
          Token (Name "add");
          Opt (
            Token (Name "column");
          );
          Token (Name "column_def");
        ];
        Seq [
          Token (Name "drop");
          Opt (
            Token (Name "column");
          );
          Token (Name "name");
        ];
      |];
    ];
  );
  "create_virtual_table_stmt",
  Some (
    Seq [
      Token (Name "create");
      Token (Name "virtual");
      Token (Name "table");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "not");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
      Token (Name "using");
      Token (Name "name");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "column_def");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "column_def");
            ];
          );
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "table_constraint");
            ];
          );
          Token (Literal ")");
        ];
      );
    ];
  );
  "create_table_stmt",
  Some (
    Seq [
      Token (Name "create");
      Opt (
        Alt [|
          Token (Name "temp");
          Token (Name "temporary");
        |];
      );
      Token (Name "table");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "not");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
      Alt [|
        Seq [
          Token (Name "as");
          Token (Name "select_stmt");
        ];
        Seq [
          Token (Literal "(");
          Token (Name "column_def");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "column_def");
            ];
          );
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "table_constraint");
            ];
          );
          Token (Literal ")");
          Opt (
            Seq [
              Token (Name "without");
              Token (Name "rowid");
            ];
          );
        ];
      |];
    ];
  );
  "insert_stmt",
  Some (
    Seq [
      Opt (
        Token (Name "with_clause");
      );
      Alt [|
        Token (Name "replace");
        Seq [
          Token (Name "insert");
          Opt (
            Seq [
              Token (Name "or");
              Alt [|
                Token (Name "abort");
                Token (Name "fail");
                Token (Name "ignore");
                Token (Name "replace");
                Token (Name "rollback");
              |];
            ];
          );
        ];
      |];
      Token (Name "into");
      Token (Name "name2");
      Opt (
        Seq [
          Token (Name "as");
          Token (Name "name");
        ];
      );
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "name");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "name");
            ];
          );
          Token (Literal ")");
        ];
      );
      Alt [|
        Seq [
          Token (Name "values");
          Token (Literal "(");
          Token (Name "expr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expr");
            ];
          );
          Token (Literal ")");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Literal "(");
              Token (Name "expr");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "expr");
                ];
              );
              Token (Literal ")");
            ];
          );
          Opt (
            Token (Name "upsert_clause");
          );
        ];
        Seq [
          Token (Name "select_stmt");
          Opt (
            Token (Name "upsert_clause");
          );
        ];
        Seq [
          Token (Name "default");
          Token (Name "values");
        ];
      |];
      Opt (
        Token (Name "returning_clause");
      );
    ];
  );
  "create_trigger_stmt",
  Some (
    Seq [
      Token (Name "create");
      Opt (
        Alt [|
          Token (Name "temp");
          Token (Name "temporary");
        |];
      );
      Token (Name "trigger");
      Opt (
        Seq [
          Token (Name "if");
          Token (Name "not");
          Token (Name "exists");
        ];
      );
      Token (Name "name2");
      Opt (
        Alt [|
          Token (Name "before");
          Token (Name "after");
          Seq [
            Token (Name "instead");
            Token (Name "of");
          ];
        |];
      );
      Alt [|
        Token (Name "delete");
        Token (Name "insert");
        Seq [
          Token (Name "update");
          Opt (
            Seq [
              Token (Name "of");
              Token (Name "name");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "name");
                ];
              );
            ];
          );
        ];
      |];
      Token (Name "on");
      Token (Name "name");
      Opt (
        Alt [|
          Seq [
            Token (Name "for");
            Token (Name "each");
            Token (Name "row");
            Opt (
              Seq [
                Token (Name "when");
                Token (Name "expr");
              ];
            );
          ];
          Seq [
            Token (Name "when");
            Token (Name "expr");
          ];
        |];
      );
      Token (Name "begin");
      Repeat1 (
        Seq [
          Alt [|
            Token (Name "update_stmt");
            Token (Name "insert_stmt");
            Token (Name "delete_stmt");
            Token (Name "select_stmt");
          |];
          Token (Literal ";");
        ];
      );
      Token (Name "end");
    ];
  );
  "sql_stmt",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "explain");
          Opt (
            Seq [
              Token (Name "query");
              Token (Name "plan");
            ];
          );
        ];
      );
      Alt [|
        Token (Name "alter_table_stmt");
        Token (Name "analyze_stmt");
        Token (Name "attach_stmt");
        Token (Name "begin_stmt");
        Token (Name "commit_stmt");
        Token (Name "create_index_stmt");
        Token (Name "create_table_stmt");
        Token (Name "create_trigger_stmt");
        Token (Name "create_view_stmt");
        Token (Name "create_virtual_table_stmt");
        Token (Name "delete_stmt");
        Token (Name "detach_stmt");
        Token (Name "drop_index_stmt");
        Token (Name "drop_table_stmt");
        Token (Name "drop_trigger_stmt");
        Token (Name "drop_view_stmt");
        Token (Name "insert_stmt");
        Token (Name "pragma_stmt");
        Token (Name "reindex_stmt");
        Token (Name "release_stmt");
        Token (Name "rollback_stmt");
        Token (Name "savepoint_stmt");
        Token (Name "select_stmt");
        Token (Name "update_stmt");
        Token (Name "vacuum_stmt");
      |];
    ];
  );
  "sql_stmt_list",
  Some (
    Seq [
      Opt (
        Token (Name "sql_stmt");
      );
      Repeat (
        Seq [
          Token (Literal ";");
          Opt (
            Token (Name "sql_stmt");
          );
        ];
      );
    ];
  );
]

let trans_nulls ((kind, body) : mt) : CST.nulls =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_current_time ((kind, body) : mt) : CST.current_time =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_into ((kind, body) : mt) : CST.into =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_insert ((kind, body) : mt) : CST.insert =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_numeric_literal ((kind, body) : mt) : CST.numeric_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_cast ((kind, body) : mt) : CST.cast =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_current_date ((kind, body) : mt) : CST.current_date =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_database ((kind, body) : mt) : CST.database =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_all ((kind, body) : mt) : CST.all =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unique ((kind, body) : mt) : CST.unique =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_do_ ((kind, body) : mt) : CST.do_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_inner ((kind, body) : mt) : CST.inner =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_temp ((kind, body) : mt) : CST.temp =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_initially ((kind, body) : mt) : CST.initially =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_instead ((kind, body) : mt) : CST.instead =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_join ((kind, body) : mt) : CST.join =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_93c883a ((kind, body) : mt) : CST.pat_93c883a =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_autoincrement ((kind, body) : mt) : CST.autoincrement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_first ((kind, body) : mt) : CST.first =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_on ((kind, body) : mt) : CST.on =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_generated ((kind, body) : mt) : CST.generated =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_set ((kind, body) : mt) : CST.set =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_delete ((kind, body) : mt) : CST.delete =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_asc ((kind, body) : mt) : CST.asc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_213dc3e ((kind, body) : mt) : CST.pat_213dc3e =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_replace ((kind, body) : mt) : CST.replace =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_virtual_ ((kind, body) : mt) : CST.virtual_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_else_ ((kind, body) : mt) : CST.else_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_vacuum ((kind, body) : mt) : CST.vacuum =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_analyze ((kind, body) : mt) : CST.analyze =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_recursive ((kind, body) : mt) : CST.recursive =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_update ((kind, body) : mt) : CST.update =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_using ((kind, body) : mt) : CST.using =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ignore ((kind, body) : mt) : CST.ignore =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_trigger ((kind, body) : mt) : CST.trigger =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_deferrable ((kind, body) : mt) : CST.deferrable =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_fail ((kind, body) : mt) : CST.fail =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_no ((kind, body) : mt) : CST.no =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_05bf793 ((kind, body) : mt) : CST.pat_05bf793 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_action ((kind, body) : mt) : CST.action =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_filter ((kind, body) : mt) : CST.filter =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null ((kind, body) : mt) : CST.null =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_cascade ((kind, body) : mt) : CST.cascade =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_explain ((kind, body) : mt) : CST.explain =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_end_ ((kind, body) : mt) : CST.end_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_range ((kind, body) : mt) : CST.range =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_after ((kind, body) : mt) : CST.after =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_or_ ((kind, body) : mt) : CST.or_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_before ((kind, body) : mt) : CST.before =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_case ((kind, body) : mt) : CST.case =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_is ((kind, body) : mt) : CST.is =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_temporary ((kind, body) : mt) : CST.temporary =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_rename ((kind, body) : mt) : CST.rename =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_exists ((kind, body) : mt) : CST.exists =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_of_ ((kind, body) : mt) : CST.of_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_each ((kind, body) : mt) : CST.each =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_query ((kind, body) : mt) : CST.query =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_window ((kind, body) : mt) : CST.window =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_foreign ((kind, body) : mt) : CST.foreign =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_indexed ((kind, body) : mt) : CST.indexed =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_check ((kind, body) : mt) : CST.check =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_in_ ((kind, body) : mt) : CST.in_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_with_ ((kind, body) : mt) : CST.with_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_as_ ((kind, body) : mt) : CST.as_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_order ((kind, body) : mt) : CST.order =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_attach ((kind, body) : mt) : CST.attach =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_drop ((kind, body) : mt) : CST.drop =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_rows ((kind, body) : mt) : CST.rows =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_current_timestamp ((kind, body) : mt) : CST.current_timestamp =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_intersect ((kind, body) : mt) : CST.intersect =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_bb5937d ((kind, body) : mt) : CST.pat_bb5937d =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ties ((kind, body) : mt) : CST.ties =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_where ((kind, body) : mt) : CST.where =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_not ((kind, body) : mt) : CST.not =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_4fd4a56 ((kind, body) : mt) : CST.pat_4fd4a56 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_between ((kind, body) : mt) : CST.between =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_begin_ ((kind, body) : mt) : CST.begin_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_glob ((kind, body) : mt) : CST.glob =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_rollback ((kind, body) : mt) : CST.rollback =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_constraint_ ((kind, body) : mt) : CST.constraint_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_union ((kind, body) : mt) : CST.union =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_when_ ((kind, body) : mt) : CST.when_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_deferred ((kind, body) : mt) : CST.deferred =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_limit ((kind, body) : mt) : CST.limit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_offset ((kind, body) : mt) : CST.offset =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_isnull ((kind, body) : mt) : CST.isnull =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_to_ ((kind, body) : mt) : CST.to_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_view ((kind, body) : mt) : CST.view =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pragma ((kind, body) : mt) : CST.pragma =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_detach ((kind, body) : mt) : CST.detach =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_release ((kind, body) : mt) : CST.release =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_table ((kind, body) : mt) : CST.table =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_references ((kind, body) : mt) : CST.references =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_29ffae5 ((kind, body) : mt) : CST.pat_29ffae5 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_73398bc ((kind, body) : mt) : CST.pat_73398bc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_like ((kind, body) : mt) : CST.like =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_outer ((kind, body) : mt) : CST.outer =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_collate ((kind, body) : mt) : CST.collate =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_primary ((kind, body) : mt) : CST.primary =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_raise ((kind, body) : mt) : CST.raise =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_transaction ((kind, body) : mt) : CST.transaction =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_conflict ((kind, body) : mt) : CST.conflict =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_distinct ((kind, body) : mt) : CST.distinct =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_whitespace ((kind, body) : mt) : CST.whitespace =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_from ((kind, body) : mt) : CST.from =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_key ((kind, body) : mt) : CST.key =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_over ((kind, body) : mt) : CST.over =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_desc ((kind, body) : mt) : CST.desc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_for_ ((kind, body) : mt) : CST.for_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_returning ((kind, body) : mt) : CST.returning =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_commit ((kind, body) : mt) : CST.commit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_exclude ((kind, body) : mt) : CST.exclude =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_exclusive ((kind, body) : mt) : CST.exclusive =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_natural ((kind, body) : mt) : CST.natural =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_current ((kind, body) : mt) : CST.current =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_restrict ((kind, body) : mt) : CST.restrict =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_notnull ((kind, body) : mt) : CST.notnull =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_partition ((kind, body) : mt) : CST.partition =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_f154b4a ((kind, body) : mt) : CST.pat_f154b4a =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_by ((kind, body) : mt) : CST.by =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_without ((kind, body) : mt) : CST.without =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_default ((kind, body) : mt) : CST.default =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_f79575e ((kind, body) : mt) : CST.pat_f79575e =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_then_ ((kind, body) : mt) : CST.then_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_cross ((kind, body) : mt) : CST.cross =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_except ((kind, body) : mt) : CST.except =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_alter ((kind, body) : mt) : CST.alter =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_group ((kind, body) : mt) : CST.group =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_materialized ((kind, body) : mt) : CST.materialized =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_stored ((kind, body) : mt) : CST.stored =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_immediate ((kind, body) : mt) : CST.immediate =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_regexp ((kind, body) : mt) : CST.regexp =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_reindex ((kind, body) : mt) : CST.reindex =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape ((kind, body) : mt) : CST.escape =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_index ((kind, body) : mt) : CST.index =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_last ((kind, body) : mt) : CST.last =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_having ((kind, body) : mt) : CST.having =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_match_ ((kind, body) : mt) : CST.match_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_rowid ((kind, body) : mt) : CST.rowid =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_create ((kind, body) : mt) : CST.create =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_if_ ((kind, body) : mt) : CST.if_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_plan ((kind, body) : mt) : CST.plan =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unbounded ((kind, body) : mt) : CST.unbounded =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_groups ((kind, body) : mt) : CST.groups =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_left ((kind, body) : mt) : CST.left =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_and_ ((kind, body) : mt) : CST.and_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_abort ((kind, body) : mt) : CST.abort =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_others ((kind, body) : mt) : CST.others =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_preceding ((kind, body) : mt) : CST.preceding =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_savepoint ((kind, body) : mt) : CST.savepoint =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_following ((kind, body) : mt) : CST.following =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_values ((kind, body) : mt) : CST.values =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_always ((kind, body) : mt) : CST.always =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_row ((kind, body) : mt) : CST.row =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_column ((kind, body) : mt) : CST.column =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_nothing ((kind, body) : mt) : CST.nothing =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_select ((kind, body) : mt) : CST.select =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_add ((kind, body) : mt) : CST.add =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_signed_number ((kind, body) : mt) : CST.signed_number =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `PLUS (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `DASH (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_numeric_literal (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_bind_parameter ((kind, body) : mt) : CST.bind_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `QMARK_rep_pat_213dc3e (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v -> trans_pat_213dc3e (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_AT_pat_93c883a (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `AT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DOLLAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `COLON (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `HASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_pat_93c883a (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DASHDASH_pat_4fd4a56 (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_4fd4a56 (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `SLASHSTAR_pat_05bf793_SLASH (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_05bf793 (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_29ffae5 (
            trans_pat_29ffae5 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DQUOT_pat_73398bc_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_73398bc (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `BQUOT_pat_bb5937d_BQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_bb5937d (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `LBRACK_pat_f154b4a_RBRACK (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_f154b4a (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_f79575e (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_compound_operator ((kind, body) : mt) : CST.compound_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Union (
            trans_union (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Union_all (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_union (Run.matcher_token v0),
                  trans_all (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Inte (
            trans_intersect (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Except (
            trans_except (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_join_operator ((kind, body) : mt) : CST.join_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `COMMA (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Opt_natu_opt_choice_left_opt_outer_join (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_natural (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Left_opt_outer (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_left (Run.matcher_token v0),
                                  Run.opt
                                    (fun v -> trans_outer (Run.matcher_token v))
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (1, v) ->
                          `Inner (
                            trans_inner (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Cross (
                            trans_cross (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  trans_join (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_conflict_clause ((kind, body) : mt) : CST.conflict_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_on (Run.matcher_token v0),
            trans_conflict (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Roll (
                  trans_rollback (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Abort (
                  trans_abort (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Fail (
                  trans_fail (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Ignore (
                  trans_ignore (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Repl (
                  trans_replace (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_name ((kind, body) : mt) : CST.function_name =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_blob_literal ((kind, body) : mt) : CST.blob_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `X_9dd4e46 (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `X_02129bb (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_string_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      trans_string_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_name ((kind, body) : mt) : CST.name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal_value ((kind, body) : mt) : CST.literal_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Nume_lit (
            trans_numeric_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Blob_lit (
            trans_blob_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Null (
            trans_null (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Curr_time_95f1cf7 (
            trans_current_time (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Curr_date (
            trans_current_date (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Curr_time_72fc600 (
            trans_current_timestamp (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_collation_name ((kind, body) : mt) : CST.collation_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_begin_stmt ((kind, body) : mt) : CST.begin_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_begin_ (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Defe (
                      trans_deferred (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Imme (
                      trans_immediate (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Excl (
                      trans_exclusive (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_transaction (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_name (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_release_stmt ((kind, body) : mt) : CST.release_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_release (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_savepoint (Run.matcher_token v))
              v1
            ,
            trans_name (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pragma_value ((kind, body) : mt) : CST.pragma_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Signed_num (
            trans_signed_number (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Name (
            trans_name (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_name ((kind, body) : mt) : CST.type_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v -> trans_name (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LPAR_signed_num_RPAR (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_signed_number (Run.matcher_token v1),
                            Run.trans_token (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `LPAR_signed_num_COMMA_signed_num_RPAR (
                      (match v with
                      | Seq [v0; v1; v2; v3; v4] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_signed_number (Run.matcher_token v1),
                            Run.trans_token (Run.matcher_token v2),
                            trans_signed_number (Run.matcher_token v3),
                            Run.trans_token (Run.matcher_token v4)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_name2 ((kind, body) : mt) : CST.name2 =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_name (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_name (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_column_name_list ((kind, body) : mt) : CST.column_name_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_name (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_detach_stmt ((kind, body) : mt) : CST.detach_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_detach (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_database (Run.matcher_token v))
              v1
            ,
            trans_name (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_savepoint_stmt ((kind, body) : mt) : CST.savepoint_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_savepoint (Run.matcher_token v0),
            trans_name (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_error_message ((kind, body) : mt) : CST.error_message =
  match body with
  | Children v ->
      trans_name (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_rollback_stmt ((kind, body) : mt) : CST.rollback_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_rollback (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_transaction (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_name (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_to_ (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_savepoint (Run.matcher_token v))
                        v1
                      ,
                      trans_name (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_commit_stmt ((kind, body) : mt) : CST.commit_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Commit (
                  trans_commit (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `End (
                  trans_end_ (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_transaction (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_name (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_foreign_key_clause ((kind, body) : mt) : CST.foreign_key_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_references (Run.matcher_token v0),
            trans_name (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_name (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.trans_token (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `On_choice_delete_choice_set_null (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_on (Run.matcher_token v0),
                            (match v1 with
                            | Alt (0, v) ->
                                `Delete (
                                  trans_delete (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Update (
                                  trans_update (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                            ,
                            (match v2 with
                            | Alt (0, v) ->
                                `Set_null (
                                  (match v with
                                  | Seq [v0; v1] ->
                                      (
                                        trans_set (Run.matcher_token v0),
                                        trans_null (Run.matcher_token v1)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | Alt (1, v) ->
                                `Set_defa (
                                  (match v with
                                  | Seq [v0; v1] ->
                                      (
                                        trans_set (Run.matcher_token v0),
                                        trans_default (Run.matcher_token v1)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | Alt (2, v) ->
                                `Casc (
                                  trans_cascade (Run.matcher_token v)
                                )
                            | Alt (3, v) ->
                                `Rest (
                                  trans_restrict (Run.matcher_token v)
                                )
                            | Alt (4, v) ->
                                `No_action (
                                  (match v with
                                  | Seq [v0; v1] ->
                                      (
                                        trans_no (Run.matcher_token v0),
                                        trans_action (Run.matcher_token v1)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Match_name (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_match_ (Run.matcher_token v0),
                            trans_name (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.opt
                        (fun v -> trans_not (Run.matcher_token v))
                        v0
                      ,
                      trans_deferrable (Run.matcher_token v1),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Alt (0, v) ->
                              `Init_defe (
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_initially (Run.matcher_token v0),
                                      trans_deferred (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                          | Alt (1, v) ->
                              `Init_imme (
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_initially (Run.matcher_token v0),
                                      trans_immediate (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_reindex_stmt ((kind, body) : mt) : CST.reindex_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_reindex (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_name2 (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_analyze_stmt ((kind, body) : mt) : CST.analyze_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_analyze (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_name2 (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_drop_view_stmt ((kind, body) : mt) : CST.drop_view_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_drop (Run.matcher_token v0),
            trans_view (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_exists (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_name2 (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qualified_table_name ((kind, body) : mt) : CST.qualified_table_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_name2 (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_as_ (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Inde_by_name (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_indexed (Run.matcher_token v0),
                            trans_by (Run.matcher_token v1),
                            trans_name (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Not_inde (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_not (Run.matcher_token v0),
                            trans_indexed (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pragma_stmt ((kind, body) : mt) : CST.pragma_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pragma (Run.matcher_token v0),
            trans_name2 (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `EQ_pragma_value (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_pragma_value (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `LPAR_pragma_value_RPAR (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_pragma_value (Run.matcher_token v1),
                            Run.trans_token (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_drop_table_stmt ((kind, body) : mt) : CST.drop_table_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_drop (Run.matcher_token v0),
            trans_table (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_exists (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_name2 (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_drop_index_stmt ((kind, body) : mt) : CST.drop_index_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_drop (Run.matcher_token v0),
            trans_index (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_exists (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_name2 (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_drop_trigger_stmt ((kind, body) : mt) : CST.drop_trigger_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_drop (Run.matcher_token v0),
            trans_trigger (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_exists (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_name2 (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_raise_function ((kind, body) : mt) : CST.raise_function =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_raise (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Ignore (
                  trans_ignore (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_roll_COMMA_error_mess (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Roll (
                              trans_rollback (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Abort (
                              trans_abort (Run.matcher_token v)
                            )
                        | Alt (2, v) ->
                            `Fail (
                              trans_fail (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v1),
                        trans_error_message (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_common_table_expression ((kind, body) : mt) : CST.common_table_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rectype (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  trans_name (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_name (Run.matcher_token v1),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_name (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v2
                            ,
                            Run.trans_token (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  trans_as_ (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.opt
                              (fun v -> trans_not (Run.matcher_token v))
                              v0
                            ,
                            trans_materialized (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4),
                  trans_select_stmt (Run.matcher_token v5),
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr ((kind, body) : mt) : CST.expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit_value (
            trans_literal_value (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bind_param (
            trans_bind_parameter (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Name (
            trans_name (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Name_DOT_name (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_name (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Name_DOT_name_DOT_name (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_name (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_name (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `TILDE_expr (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Choice_DASH_expr (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Not_expr (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_not (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Expr_BARBAR_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Expr_choice_STAR_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `SLASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `PERC (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Expr_choice_PLUS_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Expr_choice_LTLT_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `LTLT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `GTGT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `AMP (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `BAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Expr_choice_LT_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `LT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `LTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `GT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `GTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Expr_choice_EQ_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `EQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `EQEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `BANGEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `LTGT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Expr_opt_not_in_choice_LPAR_opt_choice_select_stmt_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_expr (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_not (Run.matcher_token v))
                    v1
                  ,
                  trans_in_ (Run.matcher_token v2),
                  (match v3 with
                  | Alt (0, v) ->
                      `LPAR_opt_choice_select_stmt_RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              Run.opt
                                (fun v ->
                                  (match v with
                                  | Alt (0, v) ->
                                      `Select_stmt (
                                        trans_select_stmt (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Expr_rep_COMMA_expr (
                                        (match v with
                                        | Seq [v0; v1] ->
                                            (
                                              trans_expr (Run.matcher_token v0),
                                              Run.repeat
                                                (fun v ->
                                                  (match v with
                                                  | Seq [v0; v1] ->
                                                      (
                                                        Run.trans_token (Run.matcher_token v0),
                                                        trans_expr (Run.matcher_token v1)
                                                      )
                                                  | _ -> assert false
                                                  )
                                                )
                                                v1
                                            )
                                        | _ -> assert false
                                        )
                                      )
                                  | _ -> assert false
                                  )
                                )
                                v1
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `Name2_opt_LPAR_opt_expr_rep_COMMA_expr_RPAR (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              trans_name2 (Run.matcher_token v0),
                              Run.opt
                                (fun v ->
                                  (match v with
                                  | Seq [v0; v1; v2] ->
                                      (
                                        Run.trans_token (Run.matcher_token v0),
                                        Run.opt
                                          (fun v ->
                                            (match v with
                                            | Seq [v0; v1] ->
                                                (
                                                  trans_expr (Run.matcher_token v0),
                                                  Run.repeat
                                                    (fun v ->
                                                      (match v with
                                                      | Seq [v0; v1] ->
                                                          (
                                                            Run.trans_token (Run.matcher_token v0),
                                                            trans_expr (Run.matcher_token v1)
                                                          )
                                                      | _ -> assert false
                                                      )
                                                    )
                                                    v1
                                                )
                                            | _ -> assert false
                                            )
                                          )
                                          v1
                                        ,
                                        Run.trans_token (Run.matcher_token v2)
                                      )
                                  | _ -> assert false
                                  )
                                )
                                v1
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Expr_and_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_and_ (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Expr_or_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_or_ (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Func_name_LPAR_opt_choice_opt_dist_expr_rep_COMMA_expr_RPAR_opt_filter_clause_opt_over_clause (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_function_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Opt_dist_expr_rep_COMMA_expr (
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.opt
                                    (fun v -> trans_distinct (Run.matcher_token v))
                                    v0
                                  ,
                                  trans_expr (Run.matcher_token v1),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_expr (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (1, v) ->
                          `STAR (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3),
                  Run.opt
                    (fun v -> trans_filter_clause (Run.matcher_token v))
                    v4
                  ,
                  Run.opt
                    (fun v -> trans_over_clause (Run.matcher_token v))
                    v5
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `LPAR_expr_rep_COMMA_expr_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Cast_LPAR_expr_as_type_name_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_cast (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2),
                  trans_as_ (Run.matcher_token v3),
                  trans_type_name (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | Alt (20, v) ->
          `Expr_coll_coll_name (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_collate (Run.matcher_token v1),
                  trans_collation_name (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (21, v) ->
          `Expr_opt_not_choice_like_expr_opt_esc_expr (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_expr (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_not (Run.matcher_token v))
                    v1
                  ,
                  (match v2 with
                  | Alt (0, v) ->
                      `Like (
                        trans_like (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Glob (
                        trans_glob (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Regex (
                        trans_regexp (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `Match (
                        trans_match_ (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr (Run.matcher_token v3),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_escape (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                )
            | _ -> assert false
            )
          )
      | Alt (22, v) ->
          `Expr_choice_isnull (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expr (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Isnull (
                        trans_isnull (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Notn (
                        trans_notnull (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Not_null (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              trans_not (Run.matcher_token v0),
                              trans_null (Run.matcher_token v1)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (23, v) ->
          `Expr_is_opt_not_expr (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_is (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_not (Run.matcher_token v))
                    v2
                  ,
                  trans_expr (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (24, v) ->
          `Expr_opt_not_betw_expr_and_expr (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_expr (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_not (Run.matcher_token v))
                    v1
                  ,
                  trans_between (Run.matcher_token v2),
                  trans_expr (Run.matcher_token v3),
                  trans_and_ (Run.matcher_token v4),
                  trans_expr (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | Alt (25, v) ->
          `LPAR_select_stmt_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_select_stmt (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (26, v) ->
          `Exists_LPAR_select_stmt_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_exists (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_select_stmt (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (27, v) ->
          `Not_exists_LPAR_select_stmt_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_not (Run.matcher_token v0),
                  trans_exists (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_select_stmt (Run.matcher_token v3),
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (28, v) ->
          `Case_opt_expr_rep1_when_expr_then_expr_opt_else_expr_end (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_case (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_expr (Run.matcher_token v))
                    v1
                  ,
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            trans_when_ (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1),
                            trans_then_ (Run.matcher_token v2),
                            trans_expr (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_else_ (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  trans_end_ (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (29, v) ->
          `Raise_func (
            trans_raise_function (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_filter_clause ((kind, body) : mt) : CST.filter_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_filter (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_where (Run.matcher_token v2),
            trans_expr (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_frame_spec ((kind, body) : mt) : CST.frame_spec =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Range (
                  trans_range (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rows (
                  trans_rows (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Groups (
                  trans_groups (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `Betw_choice_unbo_prec_and_choice_expr_prec (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        trans_between (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Unbo_prec (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_unbounded (Run.matcher_token v0),
                                    trans_preceding (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `Expr_prec (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_expr (Run.matcher_token v0),
                                    trans_preceding (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (2, v) ->
                            `Curr_row (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_current (Run.matcher_token v0),
                                    trans_row (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (3, v) ->
                            `Expr_foll (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_expr (Run.matcher_token v0),
                                    trans_following (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                        ,
                        trans_and_ (Run.matcher_token v2),
                        (match v3 with
                        | Alt (0, v) ->
                            `Expr_prec (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_expr (Run.matcher_token v0),
                                    trans_preceding (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `Curr_row (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_current (Run.matcher_token v0),
                                    trans_row (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (2, v) ->
                            `Expr_foll (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_expr (Run.matcher_token v0),
                                    trans_following (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (3, v) ->
                            `Unbo_foll (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_unbounded (Run.matcher_token v0),
                                    trans_following (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Unbo_prec (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_unbounded (Run.matcher_token v0),
                        trans_preceding (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Expr_prec (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_expr (Run.matcher_token v0),
                        trans_preceding (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (3, v) ->
                `Curr_row (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_current (Run.matcher_token v0),
                        trans_row (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_exclude (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Not_others (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_not (Run.matcher_token v0),
                                  trans_others (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (1, v) ->
                          `Curr_row (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_current (Run.matcher_token v0),
                                  trans_row (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (2, v) ->
                          `Group (
                            trans_group (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Ties (
                            trans_ties (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_from_clause ((kind, body) : mt) : CST.from_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_from (Run.matcher_token v0),
            trans_join_clause (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_group_by_clause ((kind, body) : mt) : CST.group_by_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_group (Run.matcher_token v0),
            trans_by (Run.matcher_token v1),
            trans_expr (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_having (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_join_clause ((kind, body) : mt) : CST.join_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_table_or_subquery (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_join_operator (Run.matcher_token v0),
                      trans_table_or_subquery (Run.matcher_token v1),
                      Run.opt
                        (fun v -> trans_join_constraint (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_join_constraint ((kind, body) : mt) : CST.join_constraint =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `On_expr (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_on (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Using_LPAR_name_rep_COMMA_name_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_using (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_name (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_name (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_limit_clause ((kind, body) : mt) : CST.limit_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_limit (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Offset_expr (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_offset (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `COMMA_expr (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_order_by_clause ((kind, body) : mt) : CST.order_by_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_order (Run.matcher_token v0),
            trans_by (Run.matcher_token v1),
            trans_ordering_term (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_ordering_term (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ordering_term ((kind, body) : mt) : CST.ordering_term =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expr (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Asc (
                      trans_asc (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Desc (
                      trans_desc (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_nulls (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `First (
                            trans_first (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Last (
                            trans_last (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_over_clause ((kind, body) : mt) : CST.over_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_over (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Name (
                  trans_name (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_opt_name_opt_part_by_expr_rep_COMMA_expr_opt_order_by_orde_term_rep_COMMA_orde_term_opt_frame_spec_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_name (Run.matcher_token v))
                          v1
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2; v3] ->
                                (
                                  trans_partition (Run.matcher_token v0),
                                  trans_by (Run.matcher_token v1),
                                  trans_expr (Run.matcher_token v2),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_expr (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v3
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2; v3] ->
                                (
                                  trans_order (Run.matcher_token v0),
                                  trans_by (Run.matcher_token v1),
                                  trans_ordering_term (Run.matcher_token v2),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_ordering_term (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v3
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                        ,
                        Run.opt
                          (fun v -> trans_frame_spec (Run.matcher_token v))
                          v4
                        ,
                        Run.trans_token (Run.matcher_token v5)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_result_column ((kind, body) : mt) : CST.result_column =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Name_DOT_STAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Expr_opt_opt_as_name (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expr (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.opt
                              (fun v -> trans_as_ (Run.matcher_token v))
                              v0
                            ,
                            trans_name (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_select_core ((kind, body) : mt) : CST.select_core =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Select_opt_choice_dist_result_column_rep_COMMA_result_column_opt_from_clause_opt_where_clause_opt_group_by_clause_opt_window_clause (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
                (
                  trans_select (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Dist (
                            trans_distinct (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `All (
                            trans_all (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  trans_result_column (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_result_column (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.opt
                    (fun v -> trans_from_clause (Run.matcher_token v))
                    v4
                  ,
                  Run.opt
                    (fun v -> trans_where_clause (Run.matcher_token v))
                    v5
                  ,
                  Run.opt
                    (fun v -> trans_group_by_clause (Run.matcher_token v))
                    v6
                  ,
                  Run.opt
                    (fun v -> trans_window_clause (Run.matcher_token v))
                    v7
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Values_LPAR_expr_rep_COMMA_expr_RPAR_rep_COMMA_LPAR_expr_rep_COMMA_expr_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_values (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2; v3; v4] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.trans_token (Run.matcher_token v1),
                            trans_expr (Run.matcher_token v2),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_expr (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v3
                            ,
                            Run.trans_token (Run.matcher_token v4)
                          )
                      | _ -> assert false
                      )
                    )
                    v5
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_select_stmt ((kind, body) : mt) : CST.select_stmt =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rectype (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.opt
                    (fun v -> trans_with_clause (Run.matcher_token v))
                    v0
                  ,
                  trans_select_core (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_compound_operator (Run.matcher_token v0),
                            trans_select_core (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.opt
                    (fun v -> trans_order_by_clause (Run.matcher_token v))
                    v3
                  ,
                  Run.opt
                    (fun v -> trans_limit_clause (Run.matcher_token v))
                    v4
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_table_or_subquery ((kind, body) : mt) : CST.table_or_subquery =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Name2_opt_opt_as_name_opt_choice_inde_by_name (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_name2 (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.opt
                              (fun v -> trans_as_ (Run.matcher_token v))
                              v0
                            ,
                            trans_name (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Inde_by_name (
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  trans_indexed (Run.matcher_token v0),
                                  trans_by (Run.matcher_token v1),
                                  trans_name (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (1, v) ->
                          `Not_inde (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_not (Run.matcher_token v0),
                                  trans_indexed (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Name2_LPAR_expr_rep_COMMA_expr_RPAR_opt_opt_as_name (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_name2 (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.opt
                              (fun v -> trans_as_ (Run.matcher_token v))
                              v0
                            ,
                            trans_name (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v5
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `LPAR_select_stmt_RPAR_opt_opt_as_name (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_select_stmt (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.opt
                              (fun v -> trans_as_ (Run.matcher_token v))
                              v0
                            ,
                            trans_name (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `LPAR_join_clause_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_join_clause (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_where_clause ((kind, body) : mt) : CST.where_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_where (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_window_clause ((kind, body) : mt) : CST.window_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_window (Run.matcher_token v0),
            trans_name (Run.matcher_token v1),
            trans_as_ (Run.matcher_token v2),
            trans_window_defn (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1),
                      trans_as_ (Run.matcher_token v2),
                      trans_window_defn (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_window_defn ((kind, body) : mt) : CST.window_defn =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_name (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      trans_partition (Run.matcher_token v0),
                      trans_by (Run.matcher_token v1),
                      trans_expr (Run.matcher_token v2),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v3
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      trans_order (Run.matcher_token v0),
                      trans_by (Run.matcher_token v1),
                      trans_ordering_term (Run.matcher_token v2),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_ordering_term (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v3
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> trans_frame_spec (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_with_clause ((kind, body) : mt) : CST.with_clause =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rectype (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_with_ (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_recursive (Run.matcher_token v))
                    v1
                  ,
                  trans_common_table_expression (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_common_table_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_filename ((kind, body) : mt) : CST.filename =
  match body with
  | Children v ->
      trans_expr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_column_constraint ((kind, body) : mt) : CST.column_constraint =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_constraint_ (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Prim_key_opt_choice_asc_opt_conf_clause_opt_auto (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        trans_primary (Run.matcher_token v0),
                        trans_key (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Alt (0, v) ->
                                `Asc (
                                  trans_asc (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Desc (
                                  trans_desc (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v -> trans_conflict_clause (Run.matcher_token v))
                          v3
                        ,
                        Run.opt
                          (fun v -> trans_autoincrement (Run.matcher_token v))
                          v4
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Opt_not_null_opt_conf_clause (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.opt
                          (fun v -> trans_not (Run.matcher_token v))
                          v0
                        ,
                        trans_null (Run.matcher_token v1),
                        Run.opt
                          (fun v -> trans_conflict_clause (Run.matcher_token v))
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Unique_opt_conf_clause (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_unique (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_conflict_clause (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (3, v) ->
                `Check_LPAR_expr_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        trans_check (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_expr (Run.matcher_token v2),
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (4, v) ->
                `Defa_choice_LPAR_expr_RPAR (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_default (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `LPAR_expr_RPAR (
                              (match v with
                              | Seq [v0; v1; v2] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    trans_expr (Run.matcher_token v1),
                                    Run.trans_token (Run.matcher_token v2)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `Lit_value (
                              trans_literal_value (Run.matcher_token v)
                            )
                        | Alt (2, v) ->
                            `Signed_num (
                              trans_signed_number (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (5, v) ->
                `Coll_coll_name (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_collate (Run.matcher_token v0),
                        trans_collation_name (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (6, v) ->
                `Fore_key_clause (
                  trans_foreign_key_clause (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Opt_gene_always_as_LPAR_expr_RPAR_opt_choice_stored (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5] ->
                      (
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_generated (Run.matcher_token v0),
                                  trans_always (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v0
                        ,
                        trans_as_ (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2),
                        trans_expr (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Alt (0, v) ->
                                `Stored (
                                  trans_stored (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Virt (
                                  trans_virtual_ (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                          v5
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_attach_stmt ((kind, body) : mt) : CST.attach_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_attach (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_database (Run.matcher_token v))
              v1
            ,
            trans_expr (Run.matcher_token v2),
            trans_as_ (Run.matcher_token v3),
            trans_name (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_indexed_column ((kind, body) : mt) : CST.indexed_column =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expr (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Asc (
                      trans_asc (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Desc (
                      trans_desc (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_create_view_stmt ((kind, body) : mt) : CST.create_view_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            trans_create (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_3d801aa (
                      trans_temp (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Temp_d5197d9 (
                      trans_temporary (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_view (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_not (Run.matcher_token v1),
                      trans_exists (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_name2 (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_name (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.trans_token (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            trans_as_ (Run.matcher_token v6),
            trans_select_stmt (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_returning_clause ((kind, body) : mt) : CST.returning_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_returning (Run.matcher_token v0),
            trans_result_column (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_result_column (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_vacuum_stmt ((kind, body) : mt) : CST.vacuum_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_vacuum (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_name (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_into (Run.matcher_token v0),
                      trans_filename (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_column_def ((kind, body) : mt) : CST.column_def =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_name (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_name (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v -> trans_column_constraint (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_table_constraint ((kind, body) : mt) : CST.table_constraint =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_constraint_ (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Choice_prim_key_LPAR_inde_column_rep_COMMA_inde_column_RPAR_opt_conf_clause (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Prim_key (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    trans_primary (Run.matcher_token v0),
                                    trans_key (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `Unique (
                              trans_unique (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v1),
                        trans_indexed_column (Run.matcher_token v2),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_indexed_column (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4),
                        Run.opt
                          (fun v -> trans_conflict_clause (Run.matcher_token v))
                          v5
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Check_LPAR_expr_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        trans_check (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_expr (Run.matcher_token v2),
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Fore_key_LPAR_name_rep_COMMA_name_RPAR_fore_key_clause (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                      (
                        trans_foreign (Run.matcher_token v0),
                        trans_key (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2),
                        trans_name (Run.matcher_token v3),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_name (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v4
                        ,
                        Run.trans_token (Run.matcher_token v5),
                        trans_foreign_key_clause (Run.matcher_token v6)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_upsert_clause ((kind, body) : mt) : CST.upsert_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_on (Run.matcher_token v0),
            trans_conflict (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_indexed_column (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_indexed_column (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.trans_token (Run.matcher_token v3),
                      Run.opt
                        (fun v -> trans_where_clause (Run.matcher_token v))
                        v4
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_do_ (Run.matcher_token v3),
            (match v4 with
            | Alt (0, v) ->
                `Noth (
                  trans_nothing (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Update_set_choice_name_EQ_expr_rep_COMMA_choice_name_EQ_expr_opt_where_clause (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                      (
                        trans_update (Run.matcher_token v0),
                        trans_set (Run.matcher_token v1),
                        (match v2 with
                        | Alt (0, v) ->
                            `Name (
                              trans_name (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Column_name_list (
                              trans_column_name_list (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v3),
                        trans_expr (Run.matcher_token v4),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2; v3] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Name (
                                        trans_name (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Column_name_list (
                                        trans_column_name_list (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                  ,
                                  Run.trans_token (Run.matcher_token v2),
                                  trans_expr (Run.matcher_token v3)
                                )
                            | _ -> assert false
                            )
                          )
                          v5
                        ,
                        Run.opt
                          (fun v -> trans_where_clause (Run.matcher_token v))
                          v6
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_create_index_stmt ((kind, body) : mt) : CST.create_index_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11] ->
          (
            trans_create (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_unique (Run.matcher_token v))
              v1
            ,
            trans_index (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_not (Run.matcher_token v1),
                      trans_exists (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_name2 (Run.matcher_token v4),
            trans_on (Run.matcher_token v5),
            trans_name (Run.matcher_token v6),
            Run.trans_token (Run.matcher_token v7),
            trans_indexed_column (Run.matcher_token v8),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_indexed_column (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v9
            ,
            Run.trans_token (Run.matcher_token v10),
            Run.opt
              (fun v -> trans_where_clause (Run.matcher_token v))
              v11
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_delete_stmt ((kind, body) : mt) : CST.delete_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> trans_with_clause (Run.matcher_token v))
              v0
            ,
            trans_delete (Run.matcher_token v1),
            trans_from (Run.matcher_token v2),
            trans_qualified_table_name (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_where_clause (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_returning_clause (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_order_by_clause (Run.matcher_token v))
              v6
            ,
            Run.opt
              (fun v -> trans_limit_clause (Run.matcher_token v))
              v7
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_update_stmt ((kind, body) : mt) : CST.update_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11; v12; v13] ->
          (
            Run.opt
              (fun v -> trans_with_clause (Run.matcher_token v))
              v0
            ,
            trans_update (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_or_ (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Abort (
                            trans_abort (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Fail (
                            trans_fail (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Ignore (
                            trans_ignore (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Repl (
                            trans_replace (Run.matcher_token v)
                          )
                      | Alt (4, v) ->
                          `Roll (
                            trans_rollback (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_qualified_table_name (Run.matcher_token v3),
            trans_set (Run.matcher_token v4),
            (match v5 with
            | Alt (0, v) ->
                `Name (
                  trans_name (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Column_name_list (
                  trans_column_name_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v6),
            trans_expr (Run.matcher_token v7),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Name (
                            trans_name (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Column_name_list (
                            trans_column_name_list (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.trans_token (Run.matcher_token v2),
                      trans_expr (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v8
            ,
            Run.opt
              (fun v -> trans_from_clause (Run.matcher_token v))
              v9
            ,
            Run.opt
              (fun v -> trans_where_clause (Run.matcher_token v))
              v10
            ,
            Run.opt
              (fun v -> trans_returning_clause (Run.matcher_token v))
              v11
            ,
            Run.opt
              (fun v -> trans_order_by_clause (Run.matcher_token v))
              v12
            ,
            Run.opt
              (fun v -> trans_limit_clause (Run.matcher_token v))
              v13
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_alter_table_stmt ((kind, body) : mt) : CST.alter_table_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_alter (Run.matcher_token v0),
            trans_table (Run.matcher_token v1),
            trans_name2 (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Rename_to_name (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_rename (Run.matcher_token v0),
                        trans_to_ (Run.matcher_token v1),
                        trans_name (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Rename_opt_column_name_to_name (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        trans_rename (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_column (Run.matcher_token v))
                          v1
                        ,
                        trans_name (Run.matcher_token v2),
                        trans_to_ (Run.matcher_token v3),
                        trans_name (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Add_opt_column_column_def (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_add (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_column (Run.matcher_token v))
                          v1
                        ,
                        trans_column_def (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (3, v) ->
                `Drop_opt_column_name (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_drop (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_column (Run.matcher_token v))
                          v1
                        ,
                        trans_name (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_create_virtual_table_stmt ((kind, body) : mt) : CST.create_virtual_table_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            trans_create (Run.matcher_token v0),
            trans_virtual_ (Run.matcher_token v1),
            trans_table (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_not (Run.matcher_token v1),
                      trans_exists (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_name2 (Run.matcher_token v4),
            trans_using (Run.matcher_token v5),
            trans_name (Run.matcher_token v6),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_column_def (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_column_def (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_table_constraint (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v3
                      ,
                      Run.trans_token (Run.matcher_token v4)
                    )
                | _ -> assert false
                )
              )
              v7
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_create_table_stmt ((kind, body) : mt) : CST.create_table_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_create (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_3d801aa (
                      trans_temp (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Temp_d5197d9 (
                      trans_temporary (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_table (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_not (Run.matcher_token v1),
                      trans_exists (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_name2 (Run.matcher_token v4),
            (match v5 with
            | Alt (0, v) ->
                `As_select_stmt (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_as_ (Run.matcher_token v0),
                        trans_select_stmt (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `LPAR_column_def_rep_COMMA_column_def_rep_COMMA_table_cons_RPAR_opt_with_rowid (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_column_def (Run.matcher_token v1),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_column_def (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_table_constraint (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_without (Run.matcher_token v0),
                                  trans_rowid (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v5
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_insert_stmt ((kind, body) : mt) : CST.insert_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> trans_with_clause (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Repl (
                  trans_replace (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Insert_opt_or_choice_abort (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_insert (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_or_ (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Abort (
                                        trans_abort (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Fail (
                                        trans_fail (Run.matcher_token v)
                                      )
                                  | Alt (2, v) ->
                                      `Ignore (
                                        trans_ignore (Run.matcher_token v)
                                      )
                                  | Alt (3, v) ->
                                      `Repl (
                                        trans_replace (Run.matcher_token v)
                                      )
                                  | Alt (4, v) ->
                                      `Roll (
                                        trans_rollback (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_into (Run.matcher_token v2),
            trans_name2 (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_as_ (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_name (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_name (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.trans_token (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            (match v6 with
            | Alt (0, v) ->
                `Values_LPAR_expr_rep_COMMA_expr_RPAR_rep_COMMA_LPAR_expr_rep_COMMA_expr_RPAR_opt_upsert_clause (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                      (
                        trans_values (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_expr (Run.matcher_token v2),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expr (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2; v3; v4] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  Run.trans_token (Run.matcher_token v1),
                                  trans_expr (Run.matcher_token v2),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_expr (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v3
                                  ,
                                  Run.trans_token (Run.matcher_token v4)
                                )
                            | _ -> assert false
                            )
                          )
                          v5
                        ,
                        Run.opt
                          (fun v -> trans_upsert_clause (Run.matcher_token v))
                          v6
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Select_stmt_opt_upsert_clause (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_select_stmt (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_upsert_clause (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Defa_values (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_default (Run.matcher_token v0),
                        trans_values (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_returning_clause (Run.matcher_token v))
              v7
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_create_trigger_stmt ((kind, body) : mt) : CST.create_trigger_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11; v12] ->
          (
            trans_create (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_3d801aa (
                      trans_temp (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Temp_d5197d9 (
                      trans_temporary (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_trigger (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_if_ (Run.matcher_token v0),
                      trans_not (Run.matcher_token v1),
                      trans_exists (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_name2 (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Before (
                      trans_before (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `After (
                      trans_after (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Inst_of (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_instead (Run.matcher_token v0),
                            trans_of_ (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            (match v6 with
            | Alt (0, v) ->
                `Delete (
                  trans_delete (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Insert (
                  trans_insert (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Update_opt_of_name_rep_COMMA_name (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_update (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  trans_of_ (Run.matcher_token v0),
                                  trans_name (Run.matcher_token v1),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_name (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_on (Run.matcher_token v7),
            trans_name (Run.matcher_token v8),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `For_each_row_opt_when_expr (
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            trans_for_ (Run.matcher_token v0),
                            trans_each (Run.matcher_token v1),
                            trans_row (Run.matcher_token v2),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_when_ (Run.matcher_token v0),
                                      trans_expr (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v3
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `When_expr (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_when_ (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v9
            ,
            trans_begin_ (Run.matcher_token v10),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Update_stmt (
                            trans_update_stmt (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Insert_stmt (
                            trans_insert_stmt (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Delete_stmt (
                            trans_delete_stmt (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Select_stmt (
                            trans_select_stmt (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v11
            ,
            trans_end_ (Run.matcher_token v12)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_sql_stmt ((kind, body) : mt) : CST.sql_stmt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_explain (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_query (Run.matcher_token v0),
                                trans_plan (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Alter_table_stmt (
                  trans_alter_table_stmt (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Anal_stmt (
                  trans_analyze_stmt (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Attach_stmt (
                  trans_attach_stmt (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Begin_stmt (
                  trans_begin_stmt (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Commit_stmt (
                  trans_commit_stmt (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Create_index_stmt (
                  trans_create_index_stmt (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Create_table_stmt (
                  trans_create_table_stmt (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Create_trig_stmt (
                  trans_create_trigger_stmt (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Create_view_stmt (
                  trans_create_view_stmt (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Create_virt_table_stmt (
                  trans_create_virtual_table_stmt (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `Delete_stmt (
                  trans_delete_stmt (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `Detach_stmt (
                  trans_detach_stmt (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `Drop_index_stmt (
                  trans_drop_index_stmt (Run.matcher_token v)
                )
            | Alt (13, v) ->
                `Drop_table_stmt (
                  trans_drop_table_stmt (Run.matcher_token v)
                )
            | Alt (14, v) ->
                `Drop_trig_stmt (
                  trans_drop_trigger_stmt (Run.matcher_token v)
                )
            | Alt (15, v) ->
                `Drop_view_stmt (
                  trans_drop_view_stmt (Run.matcher_token v)
                )
            | Alt (16, v) ->
                `Insert_stmt (
                  trans_insert_stmt (Run.matcher_token v)
                )
            | Alt (17, v) ->
                `Pragma_stmt (
                  trans_pragma_stmt (Run.matcher_token v)
                )
            | Alt (18, v) ->
                `Rein_stmt (
                  trans_reindex_stmt (Run.matcher_token v)
                )
            | Alt (19, v) ->
                `Rele_stmt (
                  trans_release_stmt (Run.matcher_token v)
                )
            | Alt (20, v) ->
                `Roll_stmt (
                  trans_rollback_stmt (Run.matcher_token v)
                )
            | Alt (21, v) ->
                `Save_stmt (
                  trans_savepoint_stmt (Run.matcher_token v)
                )
            | Alt (22, v) ->
                `Select_stmt (
                  trans_select_stmt (Run.matcher_token v)
                )
            | Alt (23, v) ->
                `Update_stmt (
                  trans_update_stmt (Run.matcher_token v)
                )
            | Alt (24, v) ->
                `Vacuum_stmt (
                  trans_vacuum_stmt (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_sql_stmt_list ((kind, body) : mt) : CST.sql_stmt_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_sql_stmt (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_sql_stmt (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "whitespace" ->
      (match translate_tree src node trans_whitespace with
      | None -> None
      | Some x -> Some (`Whitespace (Run.get_loc node, x)))
  | "comment" ->
      (match translate_tree src node trans_comment with
      | None -> None
      | Some x -> Some (`Comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_sql_stmt_list

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

